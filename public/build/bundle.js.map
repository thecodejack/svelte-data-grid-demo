{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../node_modules/deep-diff/index.js","../../node_modules/svelte-data-grid-tmp/src/edit-history.js","../../node_modules/svelte-data-grid-tmp/src/index.svelte","../../node_modules/svelte-data-grid-tmp/src/textbox-cell.svelte","../../node_modules/svelte-data-grid-tmp/src/select-cell.svelte","../../node_modules/svelte-data-grid-tmp/src/checkbox-cell.svelte","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction validate_store(store, name) {\n    if (!store || typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, callback) {\n    const unsub = store.subscribe(callback);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if (typeof $$scope.dirty === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group) {\n    const value = [];\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.push(group[i].__value);\n    }\n    return value;\n}\nfunction to_number(value) {\n    return value === '' ? undefined : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            for (let j = 0; j < node.attributes.length; j += 1) {\n                const attribute = node.attributes[j];\n                if (!attributes[attribute.name])\n                    node.removeAttribute(attribute.name);\n            }\n            return nodes.splice(i, 1)[0]; // TODO strip unwanted attributes\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    if (value != null || input.value) {\n        input.value = value;\n    }\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\nfunction add_resize_listener(element, fn) {\n    if (getComputedStyle(element).position === 'static') {\n        element.style.position = 'relative';\n    }\n    const object = document.createElement('object');\n    object.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;');\n    object.setAttribute('aria-hidden', 'true');\n    object.type = 'text/html';\n    object.tabIndex = -1;\n    let win;\n    object.onload = () => {\n        win = object.contentDocument.defaultView;\n        win.addEventListener('resize', fn);\n    };\n    if (/Trident/.test(navigator.userAgent)) {\n        element.appendChild(object);\n        object.data = 'about:blank';\n    }\n    else {\n        object.data = 'about:blank';\n        element.appendChild(object);\n    }\n    return {\n        cancel: () => {\n            win && win.removeEventListener && win.removeEventListener('resize', fn);\n            element.removeChild(object);\n        }\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nclass HtmlTag {\n    constructor(html, anchor = null) {\n        this.e = element('div');\n        this.a = anchor;\n        this.u(html);\n    }\n    m(target, anchor = null) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(target, this.n[i], anchor);\n        }\n        this.t = target;\n    }\n    u(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    p(html) {\n        this.d();\n        this.u(html);\n        this.m(this.t, this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\n\nlet stylesheet;\nlet active = 0;\nlet current_rules = {};\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    if (!current_rules[name]) {\n        if (!stylesheet) {\n            const style = element('style');\n            document.head.appendChild(style);\n            stylesheet = style.sheet;\n        }\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    node.style.animation = (node.style.animation || '')\n        .split(', ')\n        .filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    )\n        .join(', ');\n    if (name && !--active)\n        clear_rules();\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        let i = stylesheet.cssRules.length;\n        while (i--)\n            stylesheet.deleteRule(i);\n        current_rules = {};\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error(`Function called outside component initialization`);\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nfunction flush() {\n    const seen_callbacks = new Set();\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        while (dirty_components.length) {\n            const component = dirty_components.shift();\n            set_current_component(component);\n            update(component.$$);\n        }\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                callback();\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            info.blocks[i] = null;\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\n\nconst globals = (typeof window !== 'undefined' ? window : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction measure(blocks) {\n    const rects = {};\n    let i = blocks.length;\n    while (i--)\n        rects[blocks[i].key] = blocks[i].node.getBoundingClientRect();\n    return rects;\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += \" \" + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += \" \" + name;\n        }\n        else if (value != null) {\n            str += \" \" + name + \"=\" + JSON.stringify(String(value)\n                .replace(/\"/g, '&#34;')\n                .replace(/'/g, '&#39;'));\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, options = {}) => {\n            on_destroy = [];\n            const result = { head: '', css: new Set() };\n            const html = $$render(result, props, {}, options);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : ``;\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    // onMount happens before the initial afterUpdate\n    add_render_callback(() => {\n        const new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n            on_destroy.push(...new_on_destroy);\n        }\n        else {\n            // Edge case - component was destroyed immediately,\n            // most likely as a result of a binding initialising\n            run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n    });\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const prop_values = options.props || {};\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : []),\n        // everything else\n        callbacks: blank_object(),\n        dirty\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, prop_values, (i, ret, value = ret) => {\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if ($$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(children(options.target));\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set() {\n            // overridden by instance, if it has props\n        }\n    };\n}\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set() {\n        // overridden by instance, if it has props\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, detail));\n}\nfunction append_dev(target, node) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev(\"SvelteDOMRemove\", { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? [\"capture\"] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev(\"SvelteDOMAddEventListener\", { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev(\"SvelteDOMRemoveEventListener\", { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev(\"SvelteDOMRemoveAttribute\", { node, attribute });\n    else\n        dispatch_dev(\"SvelteDOMSetAttribute\", { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev(\"SvelteDOMSetProperty\", { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev(\"SvelteDOMSetDataset\", { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    dispatch_dev(\"SvelteDOMSetData\", { node: text, data });\n    text.data = data;\n}\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(`'target' is a required option`);\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn(`Component was already destroyed`); // eslint-disable-line no-console\n        };\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error(`Infinite loop detected`);\n        }\n    };\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_space, claim_text, clear_loops, component_subscribe, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, escape, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, has_prop, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_function, is_promise, listen, listen_dev, loop, loop_guard, measure, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_keyed_each, validate_component, validate_store, xlink_attr };\n",";(function(root, factory) { // eslint-disable-line no-extra-semi\n  var deepDiff = factory(root);\n  // eslint-disable-next-line no-undef\n  if (typeof define === 'function' && define.amd) {\n      // AMD\n      define('DeepDiff', function() { // eslint-disable-line no-undef\n          return deepDiff;\n      });\n  } else if (typeof exports === 'object' || typeof navigator === 'object' && navigator.product.match(/ReactNative/i)) {\n      // Node.js or ReactNative\n      module.exports = deepDiff;\n  } else {\n      // Browser globals\n      var _deepdiff = root.DeepDiff;\n      deepDiff.noConflict = function() {\n          if (root.DeepDiff === deepDiff) {\n              root.DeepDiff = _deepdiff;\n          }\n          return deepDiff;\n      };\n      root.DeepDiff = deepDiff;\n  }\n}(this, function(root) {\n  var validKinds = ['N', 'E', 'A', 'D'];\n\n  // nodejs compatible on server side and in the browser.\n  function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  }\n\n  function Diff(kind, path) {\n    Object.defineProperty(this, 'kind', {\n      value: kind,\n      enumerable: true\n    });\n    if (path && path.length) {\n      Object.defineProperty(this, 'path', {\n        value: path,\n        enumerable: true\n      });\n    }\n  }\n\n  function DiffEdit(path, origin, value) {\n    DiffEdit.super_.call(this, 'E', path);\n    Object.defineProperty(this, 'lhs', {\n      value: origin,\n      enumerable: true\n    });\n    Object.defineProperty(this, 'rhs', {\n      value: value,\n      enumerable: true\n    });\n  }\n  inherits(DiffEdit, Diff);\n\n  function DiffNew(path, value) {\n    DiffNew.super_.call(this, 'N', path);\n    Object.defineProperty(this, 'rhs', {\n      value: value,\n      enumerable: true\n    });\n  }\n  inherits(DiffNew, Diff);\n\n  function DiffDeleted(path, value) {\n    DiffDeleted.super_.call(this, 'D', path);\n    Object.defineProperty(this, 'lhs', {\n      value: value,\n      enumerable: true\n    });\n  }\n  inherits(DiffDeleted, Diff);\n\n  function DiffArray(path, index, item) {\n    DiffArray.super_.call(this, 'A', path);\n    Object.defineProperty(this, 'index', {\n      value: index,\n      enumerable: true\n    });\n    Object.defineProperty(this, 'item', {\n      value: item,\n      enumerable: true\n    });\n  }\n  inherits(DiffArray, Diff);\n\n  function arrayRemove(arr, from, to) {\n    var rest = arr.slice((to || from) + 1 || arr.length);\n    arr.length = from < 0 ? arr.length + from : from;\n    arr.push.apply(arr, rest);\n    return arr;\n  }\n\n  function realTypeOf(subject) {\n    var type = typeof subject;\n    if (type !== 'object') {\n      return type;\n    }\n\n    if (subject === Math) {\n      return 'math';\n    } else if (subject === null) {\n      return 'null';\n    } else if (Array.isArray(subject)) {\n      return 'array';\n    } else if (Object.prototype.toString.call(subject) === '[object Date]') {\n      return 'date';\n    } else if (typeof subject.toString === 'function' && /^\\/.*\\//.test(subject.toString())) {\n      return 'regexp';\n    }\n    return 'object';\n  }\n\n  // http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/\n  function hashThisString(string) {\n    var hash = 0;\n    if (string.length === 0) { return hash; }\n    for (var i = 0; i < string.length; i++) {\n      var char = string.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash;\n  }\n\n  // Gets a hash of the given object in an array order-independent fashion\n  // also object key order independent (easier since they can be alphabetized)\n  function getOrderIndependentHash(object) {\n    var accum = 0;\n    var type = realTypeOf(object);\n\n    if (type === 'array') {\n      object.forEach(function (item) {\n        // Addition is commutative so this is order indep\n        accum += getOrderIndependentHash(item);\n      });\n\n      var arrayString = '[type: array, hash: ' + accum + ']';\n      return accum + hashThisString(arrayString);\n    }\n\n    if (type === 'object') {\n      for (var key in object) {\n        if (object.hasOwnProperty(key)) {\n          var keyValueString = '[ type: object, key: ' + key + ', value hash: ' + getOrderIndependentHash(object[key]) + ']';\n          accum += hashThisString(keyValueString);\n        }\n      }\n\n      return accum;\n    }\n\n    // Non object, non array...should be good?\n    var stringToHash = '[ type: ' + type + ' ; value: ' + object + ']';\n    return accum + hashThisString(stringToHash);\n  }\n\n  function deepDiff(lhs, rhs, changes, prefilter, path, key, stack, orderIndependent) {\n    changes = changes || [];\n    path = path || [];\n    stack = stack || [];\n    var currentPath = path.slice(0);\n    if (typeof key !== 'undefined' && key !== null) {\n      if (prefilter) {\n        if (typeof (prefilter) === 'function' && prefilter(currentPath, key)) {\n          return;\n        } else if (typeof (prefilter) === 'object') {\n          if (prefilter.prefilter && prefilter.prefilter(currentPath, key)) {\n            return;\n          }\n          if (prefilter.normalize) {\n            var alt = prefilter.normalize(currentPath, key, lhs, rhs);\n            if (alt) {\n              lhs = alt[0];\n              rhs = alt[1];\n            }\n          }\n        }\n      }\n      currentPath.push(key);\n    }\n\n    // Use string comparison for regexes\n    if (realTypeOf(lhs) === 'regexp' && realTypeOf(rhs) === 'regexp') {\n      lhs = lhs.toString();\n      rhs = rhs.toString();\n    }\n\n    var ltype = typeof lhs;\n    var rtype = typeof rhs;\n    var i, j, k, other;\n\n    var ldefined = ltype !== 'undefined' ||\n      (stack && (stack.length > 0) && stack[stack.length - 1].lhs &&\n        Object.getOwnPropertyDescriptor(stack[stack.length - 1].lhs, key));\n    var rdefined = rtype !== 'undefined' ||\n      (stack && (stack.length > 0) && stack[stack.length - 1].rhs &&\n        Object.getOwnPropertyDescriptor(stack[stack.length - 1].rhs, key));\n\n    if (!ldefined && rdefined) {\n      changes.push(new DiffNew(currentPath, rhs));\n    } else if (!rdefined && ldefined) {\n      changes.push(new DiffDeleted(currentPath, lhs));\n    } else if (realTypeOf(lhs) !== realTypeOf(rhs)) {\n      changes.push(new DiffEdit(currentPath, lhs, rhs));\n    } else if (realTypeOf(lhs) === 'date' && (lhs - rhs) !== 0) {\n      changes.push(new DiffEdit(currentPath, lhs, rhs));\n    } else if (ltype === 'object' && lhs !== null && rhs !== null) {\n      for (i = stack.length - 1; i > -1; --i) {\n        if (stack[i].lhs === lhs) {\n          other = true;\n          break;\n        }\n      }\n      if (!other) {\n        stack.push({ lhs: lhs, rhs: rhs });\n        if (Array.isArray(lhs)) {\n          // If order doesn't matter, we need to sort our arrays\n          if (orderIndependent) {\n            lhs.sort(function (a, b) {\n              return getOrderIndependentHash(a) - getOrderIndependentHash(b);\n            });\n\n            rhs.sort(function (a, b) {\n              return getOrderIndependentHash(a) - getOrderIndependentHash(b);\n            });\n          }\n          i = rhs.length - 1;\n          j = lhs.length - 1;\n          while (i > j) {\n            changes.push(new DiffArray(currentPath, i, new DiffNew(undefined, rhs[i--])));\n          }\n          while (j > i) {\n            changes.push(new DiffArray(currentPath, j, new DiffDeleted(undefined, lhs[j--])));\n          }\n          for (; i >= 0; --i) {\n            deepDiff(lhs[i], rhs[i], changes, prefilter, currentPath, i, stack, orderIndependent);\n          }\n        } else {\n          var akeys = Object.keys(lhs);\n          var pkeys = Object.keys(rhs);\n          for (i = 0; i < akeys.length; ++i) {\n            k = akeys[i];\n            other = pkeys.indexOf(k);\n            if (other >= 0) {\n              deepDiff(lhs[k], rhs[k], changes, prefilter, currentPath, k, stack, orderIndependent);\n              pkeys[other] = null;\n            } else {\n              deepDiff(lhs[k], undefined, changes, prefilter, currentPath, k, stack, orderIndependent);\n            }\n          }\n          for (i = 0; i < pkeys.length; ++i) {\n            k = pkeys[i];\n            if (k) {\n              deepDiff(undefined, rhs[k], changes, prefilter, currentPath, k, stack, orderIndependent);\n            }\n          }\n        }\n        stack.length = stack.length - 1;\n      } else if (lhs !== rhs) {\n        // lhs is contains a cycle at this element and it differs from rhs\n        changes.push(new DiffEdit(currentPath, lhs, rhs));\n      }\n    } else if (lhs !== rhs) {\n      if (!(ltype === 'number' && isNaN(lhs) && isNaN(rhs))) {\n        changes.push(new DiffEdit(currentPath, lhs, rhs));\n      }\n    }\n  }\n\n  function observableDiff(lhs, rhs, observer, prefilter, orderIndependent) {\n    var changes = [];\n    deepDiff(lhs, rhs, changes, prefilter, null, null, null, orderIndependent);\n    if (observer) {\n      for (var i = 0; i < changes.length; ++i) {\n        observer(changes[i]);\n      }\n    }\n    return changes;\n  }\n\n  function orderIndependentDeepDiff(lhs, rhs, changes, prefilter, path, key, stack) {\n    return deepDiff(lhs, rhs, changes, prefilter, path, key, stack, true);\n  }\n\n  function accumulateDiff(lhs, rhs, prefilter, accum) {\n    var observer = (accum) ?\n      function (difference) {\n        if (difference) {\n          accum.push(difference);\n        }\n      } : undefined;\n    var changes = observableDiff(lhs, rhs, observer, prefilter);\n    return (accum) ? accum : (changes.length) ? changes : undefined;\n  }\n\n  function accumulateOrderIndependentDiff(lhs, rhs, prefilter, accum) {\n    var observer = (accum) ?\n      function (difference) {\n        if (difference) {\n          accum.push(difference);\n        }\n      } : undefined;\n    var changes = observableDiff(lhs, rhs, observer, prefilter, true);\n    return (accum) ? accum : (changes.length) ? changes : undefined;\n  }\n\n  function applyArrayChange(arr, index, change) {\n    if (change.path && change.path.length) {\n      var it = arr[index],\n        i, u = change.path.length - 1;\n      for (i = 0; i < u; i++) {\n        it = it[change.path[i]];\n      }\n      switch (change.kind) {\n        case 'A':\n          applyArrayChange(it[change.path[i]], change.index, change.item);\n          break;\n        case 'D':\n          delete it[change.path[i]];\n          break;\n        case 'E':\n        case 'N':\n          it[change.path[i]] = change.rhs;\n          break;\n      }\n    } else {\n      switch (change.kind) {\n        case 'A':\n          applyArrayChange(arr[index], change.index, change.item);\n          break;\n        case 'D':\n          arr = arrayRemove(arr, index);\n          break;\n        case 'E':\n        case 'N':\n          arr[index] = change.rhs;\n          break;\n      }\n    }\n    return arr;\n  }\n\n  function applyChange(target, source, change) {\n    if (typeof change === 'undefined' && source && ~validKinds.indexOf(source.kind)) {\n      change = source;\n    }\n    if (target && change && change.kind) {\n      var it = target,\n        i = -1,\n        last = change.path ? change.path.length - 1 : 0;\n      while (++i < last) {\n        if (typeof it[change.path[i]] === 'undefined') {\n          it[change.path[i]] = (typeof change.path[i + 1] !== 'undefined' && typeof change.path[i + 1] === 'number') ? [] : {};\n        }\n        it = it[change.path[i]];\n      }\n      switch (change.kind) {\n        case 'A':\n          if (change.path && typeof it[change.path[i]] === 'undefined') {\n            it[change.path[i]] = [];\n          }\n          applyArrayChange(change.path ? it[change.path[i]] : it, change.index, change.item);\n          break;\n        case 'D':\n          delete it[change.path[i]];\n          break;\n        case 'E':\n        case 'N':\n          it[change.path[i]] = change.rhs;\n          break;\n      }\n    }\n  }\n\n  function revertArrayChange(arr, index, change) {\n    if (change.path && change.path.length) {\n      // the structure of the object at the index has changed...\n      var it = arr[index],\n        i, u = change.path.length - 1;\n      for (i = 0; i < u; i++) {\n        it = it[change.path[i]];\n      }\n      switch (change.kind) {\n        case 'A':\n          revertArrayChange(it[change.path[i]], change.index, change.item);\n          break;\n        case 'D':\n          it[change.path[i]] = change.lhs;\n          break;\n        case 'E':\n          it[change.path[i]] = change.lhs;\n          break;\n        case 'N':\n          delete it[change.path[i]];\n          break;\n      }\n    } else {\n      // the array item is different...\n      switch (change.kind) {\n        case 'A':\n          revertArrayChange(arr[index], change.index, change.item);\n          break;\n        case 'D':\n          arr[index] = change.lhs;\n          break;\n        case 'E':\n          arr[index] = change.lhs;\n          break;\n        case 'N':\n          arr = arrayRemove(arr, index);\n          break;\n      }\n    }\n    return arr;\n  }\n\n  function revertChange(target, source, change) {\n    if (target && source && change && change.kind) {\n      var it = target,\n        i, u;\n      u = change.path.length - 1;\n      for (i = 0; i < u; i++) {\n        if (typeof it[change.path[i]] === 'undefined') {\n          it[change.path[i]] = {};\n        }\n        it = it[change.path[i]];\n      }\n      switch (change.kind) {\n        case 'A':\n          // Array was modified...\n          // it will be an array...\n          revertArrayChange(it[change.path[i]], change.index, change.item);\n          break;\n        case 'D':\n          // Item was deleted...\n          it[change.path[i]] = change.lhs;\n          break;\n        case 'E':\n          // Item was edited...\n          it[change.path[i]] = change.lhs;\n          break;\n        case 'N':\n          // Item is new...\n          delete it[change.path[i]];\n          break;\n      }\n    }\n  }\n\n  function applyDiff(target, source, filter) {\n    if (target && source) {\n      var onChange = function (change) {\n        if (!filter || filter(target, source, change)) {\n          applyChange(target, source, change);\n        }\n      };\n      observableDiff(target, source, onChange);\n    }\n  }\n\n  Object.defineProperties(accumulateDiff, {\n\n    diff: {\n      value: accumulateDiff,\n      enumerable: true\n    },\n    orderIndependentDiff: {\n      value: accumulateOrderIndependentDiff,\n      enumerable: true\n    },\n    observableDiff: {\n      value: observableDiff,\n      enumerable: true\n    },\n    orderIndependentObservableDiff: {\n      value: orderIndependentDeepDiff,\n      enumerable: true\n    },\n    orderIndepHash: {\n      value: getOrderIndependentHash,\n      enumerable: true\n    },\n    applyDiff: {\n      value: applyDiff,\n      enumerable: true\n    },\n    applyChange: {\n      value: applyChange,\n      enumerable: true\n    },\n    revertChange: {\n      value: revertChange,\n      enumerable: true\n    },\n    isConflict: {\n      value: function () {\n        return typeof $conflict !== 'undefined';\n      },\n      enumerable: true\n    }\n  });\n\n  // hackish...\n  accumulateDiff.DeepDiff = accumulateDiff;\n  // ...but works with:\n  // import DeepDiff from 'deep-diff'\n  // import { DeepDiff } from 'deep-diff'\n  // const DeepDiff = require('deep-diff');\n  // const { DeepDiff } = require('deep-diff');\n\n  if (root) {\n    root.DeepDiff = accumulateDiff;\n  }\n\n  return accumulateDiff;\n}));\n","import * as DeepDiff from \"deep-diff\";\nconst applyChange = DeepDiff.applyChange;\nconst diff = DeepDiff.diff;\n/**\n * Edit history tracker for a javascript object using deep-diff to generate and apply patches\n */\nexport default class EditHistory {\n  /**\n   * Instantiates an instance of EditHistory\n   * @param {Object} obj The object or array to track\n   */\n  constructor(obj) {\n    this.obj = JSON.parse(JSON.stringify(obj));\n\n    // initialize arrays for forwards and backwards patches\n    this.forward = [];\n    this.backward = [];\n  }\n\n  /**\n   * Clears all forward and backward patches\n   */\n  clear() {\n    this.forward = [];\n    this.backward = [];\n  }\n\n  /**\n   * Records a change to an object\n   * @param {Object} newObj The new object\n   */\n  recordChange(newObj) {\n    const patch = {\n      redo: diff(this.obj, newObj),\n      undo: diff(newObj, this.obj)\n    };\n\n    if (!patch.redo || !patch.undo) {\n      console.warn(\"Objects could not be diffed\");\n    } else {\n      this.obj = JSON.parse(JSON.stringify(newObj));\n      this.backward.push(patch);\n    }\n  }\n\n  /**\n   * Applies the most recent undo patch and returns the new object\n   * @returns {Object} The tracked object\n   */\n  undo() {\n    if (this.backward.length === 0) {\n      return null;\n    }\n\n    // grab the most recent backwards patch\n    const patch = this.backward.pop();\n\n    // applyChange doesn't accept arrays, only its members\n    patch.undo.forEach(x => applyChange(this.obj, x));\n\n    // put the patch into the forward queue\n    this.forward.push(patch);\n\n    return JSON.parse(JSON.stringify(this.obj));\n  }\n\n  /**\n   * Applies the most recent redo patch and returns the new object\n   * @returns {Object} The tracked object\n   */\n  redo() {\n    if (this.forward.length === 0) {\n      return null;\n    }\n\n    // grab the most recent forwards patch\n    const patch = this.forward.pop();\n\n    // applyChange doesn't accept arrays, only its members\n    patch.redo.forEach(x => applyChange(this.obj, x));\n\n    // put the patch into the backward queue\n    this.backward.push(patch);\n\n    return JSON.parse(JSON.stringify(this.obj));\n  }\n\n  /**\n   * Applies all the undo patches in the queue and returns the new object\n   * @returns {Object} The tracked object\n   */\n  undoAll() {\n    while (this.backward.length > 0) {\n      this.undo();\n    }\n\n    return this.obj;\n  }\n\n  /**\n   * Applies all the redo patches in the queue and returns the new object\n   * @returns {Object} The tracked object\n   */\n  redoAll() {\n    while (this.forward.length > 0) {\n      this.redo();\n    }\n\n    return this.obj;\n  }\n}\n","<script>\n  import { onMount, afterUpdate } from \"svelte\";\n  import EditHistory from \"./edit-history\";\n  import * as deepDiff from \"deep-diff\";\n  import { createEventDispatcher } from \"svelte\";\n\n  const dispatch = createEventDispatcher();\n\n  const MIN_COLUMN_SIZE = 30;\n\n  let wrapper;\n  let tableSpace;\n\n  /**\n   * Computes the 'left' value for a grid-cell.\n   * @param {Number} i The cell index\n   * @param {Array} columnWidths The array of column widths in order\n   * @returns {Number}\n   */\n  function getCellLeft({\n    i,\n    columnWidths,\n    __affixedColumnIndices,\n    __scrollLeft\n  }) {\n    if (__affixedColumnIndices.indexOf(i) >= 0) {\n      if (i === 0) {\n        return __scrollLeft;\n      }\n      let left = __scrollLeft;\n      for (let j = i - 1; j >= 0; j--) {\n        left += columnWidths[j];\n      }\n      return left;\n    }\n\n    let left = 0;\n    for (let j = 0; j < i; j++) {\n      left += columnWidths[j];\n    }\n    return left;\n  }\n\n  /**\n   * Gets the closest column index given an x offset\n   * @param {Number} x The x offset\n   * @param {Array} columnWidths Array of column widths\n   * @param {Array} __affixedColumnIndices Array of column indices that have been affixed\n   * @param {Number} __scrollLeft The scrollLeft value of the scrollable container\n   * @returns {Number}\n   */\n\n  function getClosestIndex(\n    x,\n    columnWidths,\n    __affixedColumnIndices,\n    __scrollLeft\n  ) {\n    let closest = 0;\n\n    for (let i = 0; i < columnWidths.length; i++) {\n      const left =\n        getCellLeft({ i, columnWidths, __affixedColumnIndices, __scrollLeft }) +\n        Math.floor(columnWidths[i] / 2);\n\n      if (left < x) {\n        closest = i + 1;\n      }\n    }\n\n    // special handling required when there are affixed columns, because\n    // if the grid is scrolled horizontally to the right, we want to have this function return the closest\n    // affixed column, rather than any columns that might be closer to x but are being overlapped by an affixed column\n    if (__affixedColumnIndices.length > 0) {\n      const firstAffixedLeft = getCellLeft({\n        i: __affixedColumnIndices[0],\n        columnWidths,\n        __affixedColumnIndices,\n        __scrollLeft\n      });\n      const lastAffixedLeft = getCellLeft({\n        i: __affixedColumnIndices[__affixedColumnIndices.length - 1],\n        columnWidths,\n        __affixedColumnIndices,\n        __scrollLeft\n      });\n      const lastAffixedRight =\n        lastAffixedLeft +\n        columnWidths[__affixedColumnIndices[__affixedColumnIndices.length - 1]];\n      const closestLeft = getCellLeft({\n        i: closest,\n        columnWidths,\n        __affixedColumnIndices,\n        __scrollLeft\n      });\n      if (closestLeft > firstAffixedLeft && closestLeft < lastAffixedRight) {\n        if (closestLeft < lastAffixedRight && closestLeft > lastAffixedLeft) {\n          closest = __affixedColumnIndices[__affixedColumnIndices.length - 1];\n        } else {\n          for (let i = 0; i < __affixedColumnIndices.length; i++) {\n            const left =\n              getCellLeft({\n                i: __affixedColumnIndices[i],\n                columnWidths,\n                __affixedColumnIndices,\n                __scrollLeft\n              }) + Math.floor(columnWidths[__affixedColumnIndices[i]] / 2);\n\n            if (left < x) {\n              closest = __affixedColumnIndices[i] + 1;\n            }\n          }\n        }\n      }\n    }\n\n    return closest;\n  }\n\n  function getBodyScrollTop() {\n    return (\n      window.pageYOffset ||\n      (document.documentElement.clientHeight\n        ? document.documentElement.scrollTop\n        : document.body.scrollTop)\n    );\n  }\n\n  let editHistory = null;\n\n  export let rows = []; // Rows to display\n  export let columns = []; // Array of column definitions: { display: '', dataName: ''}, where display is what the display value is and dataName is what the key on the row object is\n  export let rowHeight = 24; // Row height in pixels\n  export let allowResizeFromTableCells = false; // Allow the user to click on table cell borders to resize columns\n  export let allowResizeFromTableHeaders = true; // Allow the user to clikc on table header borders to resize columns\n  export let allowColumnReordering = true; // Allow the user to drag column headers to reorder columns\n  export let allowColumnAffix = true; // Alow the user to affix columns to the left of the grid\n\n  export let __extraRows = 0; // Number of extra rows to render beyond what is visible in the scrollable area\n  export let __columnHeaderResizeCaptureWidth = 20; // The width of the area on column borders that can be clicked to resize the column\n  /**** Do not modify any of the data variables below ****/\n  export let __affixedRowIndices = []; // DO NOT MODIFY DIRECTLY. The row indices to affix to the top of the grid\n  export let __affixedColumnIndices = []; // DO NOT MODIFY DIRECTLY. The column indices to affix to the left side of the grid\n  export let __affixingRow = false; // DO NOT MODIFY DIRECTLY. Whether a row affix operation is in progress\n  export let __affixingColumn = false; // DO NOT MODIFY DIRECTLY. Whether a column affix operation is in progress\n  export let __rowActionLineTop = 0; // DO NOT MODIFY DIRECTLY. The 'top' position of the row action line\n  export let __rowAffixLineTop = 0; // DO NOT MODIFY DIRECTLY. The 'top' position of the row affix line\n  export let __columnAffixLineLeft = 0; // DO NOT MODIFY DIRECTLY. The 'left' position of the column affix line\n  export let __columnDragging = false; // DO NOT MODIFY DIRECTLY. Whether a column is being dragged\n  export let __columnIndexBeingDragged = null; // DO NOT MODIFY DIRECTLY. The column index that is being dragged\n  export let __columnDragOffsetX = 0; // DO NOT MODIFY DIRECTLY. The X offset of where the user clicked on the column header\n  export let __resizing = false; // DO NOT MODIFY DIRECTLY. Whether or not a column is currently being resized\n  export let __columnIndexBeingResized = null; // DO NOT MODIFY DIRECTLY. The column index being resized\n  export let __columnActionLineLeft = 0; // DO NOT MODIFY DIRECTLY. The 'left' position of the action line\n  export let __innerOffsetHeight = 0; // DO NOT MODIFY DIRECTLY. The height of the scrollable area on screen\n  export let __scrollTop = 0; // DO NOT MODIFY DIRECTLY. The scrollTop position of the scrollable area\n  export let __scrollLeft = 0; // DO NOT MODIFY DIRECTLY. The scrollLeft position of the scrollable area\n  export let __scrolledAllTheWayToTheRight = false; // DO NOT MODIFY DIRECTLY. Whether the container is scrolled all the way to the right as of the last onscroll event\n\n  onMount(() => {\n    editHistory = new EditHistory(rows);\n  });\n\n  /**\n   * TODO handle svelte 2's onupdate\n   **/\n  // onupdate(({ changed, current, previous }) => {\n  //   // Record the change in onupdate to allow the DOM to change before doing the deep diff\n  //   if (changed.rows && previous && previous.rows && previous.rows.length > 0) {\n  //     if (!current.skipRecord) {\n  //       this.editHistory.recordChange(current.rows);\n  //     } else {\n  //       this.set({ skipRecord: false });\n  //     }\n  //   }\n  // });\n\n  /**\n   * This action creates a half-opaque 'ghost' column header to visualize dragging a column into a different position\n   * This is put in an action because ultimately the ghost image has nothing to do with the actual column index move\n   */\n  function dragCopy(node, enabled) {\n    let copy = null;\n    let dragging = false;\n    let offsetX = 0;\n\n    function onWindowMouseMove(event) {\n      if (!dragging) {\n        return;\n      }\n      copy.style.left = event.pageX - offsetX + \"px\";\n    }\n\n    function onWindowMouseUp(event) {\n      if (!dragging || event.which !== 1) {\n        return;\n      }\n\n      dragging = false;\n      document.body.removeChild(copy);\n      copy = null;\n    }\n\n    function onNodeMouseDown(event) {\n      if (event.which !== 1) {\n        return;\n      }\n\n      dragging = true;\n      if (copy) {\n        document.body.removeChild(copy);\n      }\n\n      copy = createCopy();\n      offsetX = event.offsetX;\n      copy.style.top =\n        node.getBoundingClientRect().top + getBodyScrollTop() + \"px\";\n      copy.style.left = event.pageX - offsetX + \"px\";\n      document.body.appendChild(copy);\n    }\n\n    function createCopy() {\n      const copy = document.createElement(\"div\");\n      copy.innerHTML = node.innerHTML;\n      const { width, height, textAlign, fontWeight } = getComputedStyle(node);\n      copy.style.width = width;\n      copy.style.height = height;\n      copy.style.maxHeight = height;\n      copy.style.textAlign = textAlign;\n      copy.style.fontWeight = fontWeight;\n      copy.style.position = \"absolute\";\n      copy.style.opacity = \"0.5\";\n      copy.style.pointerEvents = \"none\";\n      copy.style.overflow = \"hidden\";\n      copy.style.background = \"#dddddd\";\n      copy.style[\"z-index\"] = \"99999\";\n\n      return copy;\n    }\n\n    function attachEvents() {\n      window.addEventListener(\"mousemove\", onWindowMouseMove);\n      window.addEventListener(\"mouseup\", onWindowMouseUp);\n      node.addEventListener(\"mousedown\", onNodeMouseDown);\n    }\n\n    function detachEvents() {\n      window.removeEventListener(\"mousemove\", onWindowMouseMove);\n      window.removeEventListener(\"mouseup\", onWindowMouseUp);\n      node.removeEventListener(\"mousedown\", onNodeMouseDown);\n    }\n    if (enabled) {\n      attachEvents();\n    }\n\n    return {\n      destroy() {\n        detachEvents();\n      },\n      update(enabled) {\n        if (enabled) {\n          attachEvents();\n        } else {\n          detachEvents();\n        }\n      }\n    };\n  }\n\n  function onWindowKeyDown(event) {\n    if (event.ctrlKey) {\n      if (event.keyCode === 90) {\n        undo();\n        event.preventDefault();\n      }\n\n      if (event.keyCode === 89) {\n        redo();\n        event.preventDefault();\n      }\n    }\n  }\n\n  /**\n   * Event handler for window's mousemove event\n   * @param {MouseEvent} event The MouseEvent object\n   */\n  function onMouseMove(event) {\n    onColumnDragMouseMove(event);\n    onColumnResizeMouseMove(event);\n    onRowAffixMouseMove(event);\n    onColumnAffixMouseMove(event);\n  }\n\n  /**\n   * Event handler for window's mouseup event\n   * @param {MouseEvent} event The MouseEvent object\n   */\n  function onMouseUp(event) {\n    onColumnDragEnd(event);\n    onColumnResizeEnd(event);\n    onRowAffixEnd(event);\n    onColumnAffixEnd(event);\n  }\n\n  /**\n   * Event handler for when a value has been updated\n   * @param {Object} event Event object with row and column objects\n   */\n  function onCellUpdated(event) {\n    rows[event.detail.rowNumber][event.detail.column.dataName] =\n      event.detail.value;\n    dispatch(\"valueUpdated\", event);\n  }\n\n  /**\n   * Applies the most recent backward change\n   */\n  function undo() {\n    const eRows = editHistory.undo();\n    if (eRows) {\n      rows = eRows;\n    }\n  }\n\n  /**\n   * Applies the most recent forward change\n   */\n\n  function redo() {\n    const eRows = editHistory.redo();\n    if (eRows) {\n      rows = eRows;\n    }\n  }\n\n  /**\n   * Event handler for starting column affix operation\n   */\n  function onColumnAffixStart(event) {\n    // left click only\n    if (event.which !== 1) {\n      return;\n    }\n    if (__affixedColumnIndices.length > 0) {\n      tableSpace.scrollLeft = 0;\n      __affixingColumn = true;\n    } else {\n      __affixingColumn = true;\n    }\n  }\n\n  /**\n   * Event handler for mousemove column affix operation\n   */\n  function onColumnAffixMouseMove(event) {\n    if (!__affixingColumn) {\n      return;\n    }\n\n    if (event.which !== 1) {\n      onColumnAffixEnd(event);\n      return;\n    }\n\n    const { left: wrapperPageX } = wrapper.getBoundingClientRect();\n\n    const offsetPoint = event.pageX - wrapperPageX + __scrollLeft;\n\n    const idx = getClosestIndex(\n      offsetPoint,\n      columnWidths,\n      __affixedColumnIndices,\n      __scrollLeft\n    );\n    const indices = [];\n    for (let i = 0; i < idx; i++) {\n      indices.push(i);\n    }\n\n    __columnActionLineLeft = offsetPoint;\n    __affixedColumnIndices = indices;\n    event.preventDefault();\n\n    // check to see if horizontal scroll position doesn't match where the\n  }\n\n  /**\n   * Event handler for ending column affix operation\n   */\n  function onColumnAffixEnd(event) {\n    __affixingColumn = false;\n  }\n\n  /**\n   * Event handler for starting row affix operation\n   */\n  function onRowAffixStart(event) {\n    __affixingRow = true;\n  }\n\n  /**\n   * Event handler for mousemove row affix operation\n   */\n  function onRowAffixMouseMove(event) {\n    if (!__affixingRow) {\n      return;\n    }\n  }\n\n  /**\n   * Event handler for ending row affix operation\n   */\n  function onRowAffixEnd(event) {\n    __affixingRow = false;\n  }\n\n  /**\n   * Event handler for column dragging\n   */\n  function onColumnDragStart(event, columnIndex) {\n    if (event.which !== 1) {\n      return;\n    }\n\n    // if the developer has disabled column reordering, don't begin a reorder\n    if (!allowColumnReordering) {\n      return;\n    }\n\n    __columnDragging = true;\n    __columnIndexBeingDragged = columnIndex;\n    __columnDragOffsetX = event.offsetX;\n    __columnActionLineLeft =\n      getCellLeft({\n        i: columnIndex,\n        columnWidths,\n        __scrollLeft,\n        __affixedColumnIndices\n      }) - __scrollLeft;\n  }\n\n  function onColumnDragMouseMove(event) {\n    if (!__columnDragging) {\n      return;\n    }\n\n    // if user is no longer pressing the left mouse button and we are out of sync\n    // with __columnDragging because mouseup didn't fire, finish the reorder\n    if (event.which !== 1) {\n      onColumnDragEnd(event);\n      return;\n    }\n\n    const { left: wrapperPageX } = wrapper.getBoundingClientRect();\n\n    // change the position of the action line to the closest column index under the mouse\n    const offsetPoint =\n      event.pageX - wrapperPageX + __scrollLeft - __columnDragOffsetX;\n    const idx = getClosestIndex(\n      offsetPoint,\n      columnWidths,\n      __affixedColumnIndices,\n      __scrollLeft\n    );\n    __columnActionLineLeft =\n      getCellLeft({\n        i: idx,\n        columnWidths,\n        __affixedColumnIndices,\n        __scrollLeft\n      }) - __scrollLeft;\n  }\n\n  /**\n   * Window mouseup handler for column dragging\n   */\n  function onColumnDragEnd(event) {\n    // user might try to be clever and middle-click to scroll horizontally while dragging a column\n    // don't stop the drag for middle clicks\n    if (event.which !== 1) {\n      return;\n    }\n\n    // if a column isn't being dragged, don't reorder anything\n    if (!__columnDragging) {\n      return;\n    }\n\n    const { left: wrapperPageX } = wrapper.getBoundingClientRect();\n    const offsetPoint =\n      event.pageX - wrapperPageX + __scrollLeft - __columnDragOffsetX;\n\n    // move column object to its new position in the array based off the mouse position and scroll position\n    const newIdx = getClosestIndex(\n      offsetPoint,\n      columnWidths,\n      __affixedColumnIndices,\n      __scrollLeft\n    );\n    let mColumns = columns;\n    mColumns.splice(\n      newIdx > __columnIndexBeingDragged ? newIdx - 1 : newIdx,\n      0,\n      mColumns.splice(__columnIndexBeingDragged, 1)[0]\n    );\n    columns = mColumns;\n    // delay firing of event so that new column order is accessible when handlers are called\n    setTimeout(() => dispatch(\"columnOrderUpdated\"), 0);\n\n    __columnDragging = false;\n    __columnDragOffsetX = 0;\n    __columnIndexBeingDragged = null;\n  }\n\n  /**\n   * Mousedown handler for column resizing\n   */\n  function onColumnResizeStart(event, columnIndex) {\n    // left click only\n    if (event.which !== 1) {\n      return;\n    }\n    const { left: wrapperPageX } = wrapper.getBoundingClientRect();\n\n    __resizing = true;\n    __columnActionLineLeft = event.pageX - wrapperPageX - __scrollLeft;\n    __columnIndexBeingResized = columnIndex;\n    event.stopPropagation();\n  }\n\n  /**\n   * Mousemove handler for column resizing\n   */\n  function onColumnResizeMouseMove(event) {\n    // if not currently resizing a column, ignore the event\n    if (!__resizing) {\n      return;\n    }\n\n    const { left: wrapperPageX } = wrapper.getBoundingClientRect();\n\n    const resizeLineLeft = event.pageX - wrapperPageX;\n    const columnLeft = getCellLeft({\n      i: __columnIndexBeingResized,\n      columnWidths,\n      __affixedColumnIndices,\n      __scrollLeft\n    });\n    const resizeLineMinLeft = columnLeft - __scrollLeft + MIN_COLUMN_SIZE;\n    const newColumnWidth = Math.max(\n      resizeLineLeft + __scrollLeft - columnLeft,\n      MIN_COLUMN_SIZE\n    );\n    // thanks to the virtual list, we're able to get away with setting the column's size while the mouse moves\n    columns[__columnIndexBeingResized].width = newColumnWidth;\n\n    __columnActionLineLeft = Math.max(resizeLineLeft, resizeLineMinLeft);\n\n    // If mouseup was not fired for some reason, abort the resize\n    if (event.which !== 1) {\n      __resizing = false;\n      __columnIndexBeingResized = null;\n\n      // delay firing the event until the next frame to guarantee that new values will be available in component.get()\n      setTimeout(\n        () =>\n          dispatch(\"columnWidthUpdated\", {\n            idx: __columnIndexBeingResized,\n            width: newColumnWidth\n          }),\n        0\n      );\n    }\n\n    // if still resizing and the user does not have the left mouse button depressed,\n    // the mouseup event didn't fire for some reason, so turn off the resize mode\n  }\n\n  /**\n   * Mouseup handler for column resizing\n   */\n  function onColumnResizeEnd(event) {\n    if (!__resizing) {\n      return;\n    }\n\n    dispatch(\"columnWidthUpdated\");\n    __resizing = false;\n    __columnIndexBeingResized = null;\n  }\n\n  /**\n   * Sets updated scroll values when the scrollable area is scrolled\n   */\n  function onScroll() {\n    // get new scroll values from the scroll area\n    const { scrollTop: newScrollTop, scrollLeft: newScrollLeft } = tableSpace;\n\n    /*\n     * To avoid doing unnecessary re-calculation of computed variables, don't set the scroll\n     * properties that haven't changed\n     */\n    if (__scrollTop !== newScrollTop) {\n      __scrollTop = newScrollTop;\n    }\n\n    if (__scrollLeft !== newScrollLeft) {\n      __scrollLeft = newScrollLeft;\n    }\n\n    __scrolledAllTheWayToTheRight =\n      Math.ceil(tableSpace.scrollWidth - tableSpace.scrollLeft) ===\n      tableSpace.clientWidth;\n  }\n\n  /**\n   * Computed Properties\n   */\n\n  /**\n   * The 'left' value of the column affix line\n   */\n\n  let columnAffixLineLeft = 0; //TODO setter probably not needed due to reactive statement\n\n  $: {\n    // if no columns are affixed, set the line all the way to the left\n    if (__affixedColumnIndices.length === 0) {\n      columnAffixLineLeft = 0;\n    }\n\n    let left = __scrollLeft;\n    for (let i = 0; i < __affixedColumnIndices.length; i++) {\n      left += columnWidths[__affixedColumnIndices[i]];\n    }\n\n    columnAffixLineLeft = left;\n  }\n\n  /**\n   * Array of column widths\n   */\n  let columnWidths = columns.map(x => x.width || MIN_COLUMN_SIZE); //TODO setter probably not needed due to reactive statement\n\n  $: {\n    // if width was not provided for this column, give it a default value\n    columnWidths = columns.map(x => x.width || MIN_COLUMN_SIZE);\n  }\n\n  /**\n   * The number of rows we have\n   */\n  let numRows = rows.length; //TODO setter probably not needed due to reactive statement\n\n  $: {\n    numRows = rows.length;\n  }\n\n  /**\n   * Width of the overall grid space\n   */\n  let gridSpaceWidth = 0; //TODO setter probably not needed due to reactive statement\n\n  $: {\n    let sum = 0;\n    for (let i = 0; i < columnWidths.length; i++) {\n      sum += columnWidths[i];\n    }\n\n    /**\n     * If the table is scrolled all the way to the right, resizing columns could\n     * accelerate until the column is the minimum width. Add some extra space on the right\n     * to ensure this undesired behavior does not happen. This doesn't seem like a perfect solution\n     * but it works for now until I can think of something better.\n     */\n\n    if (__resizing && __scrolledAllTheWayToTheRight) {\n      sum *= 2;\n    }\n\n    gridSpaceWidth = sum;\n  }\n\n  /**\n   * Height of the overall grid space\n   */\n  let gridSpaceHeight = rowHeight * numRows; //TODO setter probably not needed due to reactive statement\n  $: {\n    gridSpaceHeight = rowHeight * numRows;\n  }\n\n  /**\n   * Number of rows to render in the viewport\n   */\n  let numRowsInViewport = Math.ceil(__innerOffsetHeight / rowHeight);\n\n  $: {\n    numRowsInViewport = Math.ceil(__innerOffsetHeight / rowHeight);\n  }\n\n  /**\n   * Computes which rows should be visible\n   */\n  let visibleRows;\n\n  $: {\n    const start = Math.max(\n      0,\n      Math.floor(__scrollTop / rowHeight - __extraRows / 2)\n    );\n    const end = start + numRowsInViewport + __extraRows;\n\n    visibleRows = rows.slice(start, end).map((x, i) => {\n      return {\n        i: i + start, // for aria-rowindex\n        data: x // the row data\n      };\n    });\n  }\n\n  /**\n   * Helpers\n   */\n  const getCellZIndex = function(__affixedColumnIndices, i) {\n    return __affixedColumnIndices.indexOf(i) === -1 ? 1 : 2;\n  };\n\n  /**\n   * Gets the 'top' value for a grid-row\n   */\n  const getRowTop = function(i, rowHeight) {\n    return i * rowHeight;\n  };\n\n  // const getCellLeft =getCellLeft\n</script>\n\n<style>\n  .row-action-line {\n    position: absolute;\n    left: 0;\n    width: 100%;\n    height: 4px;\n    z-index: 6;\n    background: #aaa;\n  }\n\n  .row-affix-marker {\n    display: none;\n    position: absolute;\n    left: 0;\n    height: 4px;\n    z-index: 6;\n    background: white;\n    border-top: 1px solid #999;\n    border-bottom: 1px solid #999;\n\n    cursor: ns-resize;\n  }\n\n  .column-affix-marker {\n    position: absolute;\n    top: 0;\n    width: 4px;\n    z-index: 5;\n    background: white;\n    border-left: 1px solid #999;\n    border-right: 1px solid #999;\n    cursor: ew-resize;\n    transform: translateX(-50%);\n  }\n\n  .resizing * {\n    user-select: none;\n  }\n\n  .resizing .grid-inner {\n    overflow-y: hidden;\n  }\n\n  .resizing .grid-space {\n    pointer-events: all;\n  }\n\n  .grid-cell > * {\n    height: 100%;\n  }\n\n  .cell-default {\n    padding: 0 5px;\n    background: white;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n\n  .data-grid-wrapper {\n    position: relative;\n    width: 100%;\n    height: 100%;\n  }\n\n  .column-action-line {\n    position: absolute;\n    top: 0;\n    bottom: 17px;\n    z-index: 3;\n    width: 4px;\n    background: #aaa;\n    cursor: ew-resize;\n  }\n\n  .grid-cell-size-capture {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    z-index: 5;\n    background: transparent;\n    cursor: ew-resize;\n    pointer-events: all;\n  }\n\n  .grid-inner {\n    overflow: auto;\n  }\n\n  .grid-space {\n    position: absolute;\n    top: 0;\n    left: 0;\n    background: transparent;\n    pointer-events: none;\n\n    z-index: 3;\n  }\n\n  .grid-headers {\n    position: absolute;\n    overflow: hidden;\n    max-width: 100%;\n    width: 100%;\n    top: 0;\n    left: 0;\n    border-bottom: 2px solid black;\n  }\n\n  .grid-headers .grid-cell {\n    text-align: center;\n    font-weight: bold;\n    cursor: pointer;\n  }\n\n  .grid-headers .cell-default:hover {\n    background: #eee;\n  }\n\n  .grid-header-row {\n    position: absolute;\n    overflow: hidden;\n    top: 0;\n  }\n\n  .grid-row {\n    position: absolute;\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n  }\n\n  .grid-row:not(:last-child) {\n    border-bottom: 1px solid #666;\n  }\n\n  .grid-cell {\n    position: absolute;\n    top: 0;\n    text-overflow: ellipsis;\n    overflow: hidden;\n  }\n\n  .grid-cell > * {\n    width: 100%;\n  }\n\n  .grid-cell:not(:last-child) {\n    border-right: 1px solid #666;\n  }\n</style>\n\n<svelte:window\n  on:mouseup={onMouseUp}\n  on:mousemove={onMouseMove}\n  on:keydown={onWindowKeyDown} />\n<div\n  class=\"data-grid-wrapper {__resizing || __columnDragging ? 'resizing' : ''}\"\n  style=\"padding-top: {rowHeight}px;\"\n  bind:this={wrapper}\n  role=\"table\">\n  {#if __resizing || __columnDragging || __affixingColumn}\n    <div\n      class=\"column-action-line\"\n      style=\"left: {__columnActionLineLeft - 2}px;\" />\n  {/if}\n  {#if __affixingRow}\n    <div class=\"row-action-line\" style=\"top: {__rowActionLineTop - 2}px;\" />\n  {/if}\n\n  <div class=\"grid-headers\" style=\"height: {rowHeight}px;\" rolw=\"rowgroup\">\n    <!-- We link up the horizontal scrolling of the inner grid view with the sticky header row by making the\n      -- header row width 100% of the container, and using position:absolute along with 'left' to\n      -- control the 'scroll' of the header row -->\n    <div\n      class=\"grid-header-row\"\n      style=\"left: -{__scrollLeft}px; height: {rowHeight}px; width: {gridSpaceWidth}px;\"\n      role=\"row\">\n      {#each columns as column, i (i)}\n        <div\n          class=\"grid-cell\"\n          on:mousedown={event => onColumnDragStart(event, i)}\n          style=\"z-index: {getCellZIndex(__affixedColumnIndices, i)}; left: {getCellLeft(\n            { i, columnWidths, __affixedColumnIndices, __scrollLeft }\n          )}px; width: {columnWidths[i]}px; height: {rowHeight}px; line-height: {rowHeight}px;\"\n          title={column.display || ''}\n          use:dragCopy={allowColumnReordering}\n          role=\"columnheader\">\n          {#if column.headerComponent}\n            <svelte:component this={column.headerComponent} {column} />\n          {:else}\n            <div class=\"cell-default\">{column.display || ''}</div>\n          {/if}\n        </div>\n        {#if allowResizeFromTableHeaders && !column.disallowResize}\n          <div\n            class=\"grid-cell-size-capture\"\n            style=\"left: {getCellLeft({\n              i: i,\n              columnWidths,\n              __affixedColumnIndices,\n              __scrollLeft\n            }) + columnWidths[i] - Math.floor(__columnHeaderResizeCaptureWidth / 2)}px;\n            width: {__columnHeaderResizeCaptureWidth}px;\"\n            on:mousedown={event => onColumnResizeStart(event, i)} />\n        {/if}\n      {/each}\n    </div>\n  </div>\n\n  <div\n    class=\"grid-inner\"\n    bind:this={tableSpace}\n    bind:offsetHeight={__innerOffsetHeight}\n    on:scroll={onScroll}\n    style=\"height: 100%;\"\n    role=\"rowgroup\">\n\n    {#if allowColumnAffix}\n      <div\n        class=\"column-affix-marker\"\n        style=\"left: {columnAffixLineLeft}px; height: {gridSpaceHeight}px;\"\n        on:mousedown={onColumnAffixStart} />\n    {/if}\n    <div\n      class=\"row-affix-marker\"\n      style=\"top: {__rowAffixLineTop}px; width: {gridSpaceWidth}px;\"\n      on:mousedown={onRowAffixStart} />\n\n    <!-- We need an element to take up space so our scrollbars appear-->\n    <div\n      class=\"grid-space\"\n      style=\"width: {gridSpaceWidth}px; height: {gridSpaceHeight}px;\">\n      {#if allowResizeFromTableCells}\n        {#each columns as column, i}\n          {#if !column.disallowResize}\n            <div\n              class=\"grid-cell-size-capture\"\n              style=\"left: {getCellLeft({\n                i: i + 1,\n                columnWidths,\n                __affixedColumnIndices,\n                __scrollLeft\n              }) - Math.floor(__columnHeaderResizeCaptureWidth / 2)}px; width: {__columnHeaderResizeCaptureWidth}px;\"\n              on:mousedown={event => onColumnResizeStart(event, i)} />\n          {/if}\n        {/each}\n      {/if}\n    </div>\n\n    <!-- Loop through the visible rows and display the data-->\n    <!-- Scrolling seems to perform better when not using a keyed each block -->\n    {#each visibleRows as row, i}\n      <div\n        class=\"grid-row\"\n        style=\"top: {getRowTop(row.i, rowHeight)}px; height: {rowHeight}px;\n        width: {gridSpaceWidth}px;\"\n        role=\"row\"\n        aria-rowindex={row.i}>\n        {#each columns as column, j}\n          <div\n            class=\"grid-cell\"\n            style=\"z-index: {getCellZIndex(__affixedColumnIndices, j)}; left: {getCellLeft(\n              { i: j, columnWidths, __affixedColumnIndices, __scrollLeft }\n            )}px; height: {rowHeight}px; line-height: {rowHeight}px; width: {columnWidths[j]}px;\"\n            role=\"cell\">\n            {#if column.cellComponent}\n              <svelte:component\n                this={column.cellComponent}\n                rowNumber={row.i}\n                {column}\n                {row}\n                on:valueupdate={onCellUpdated} />\n            {:else}\n              <div class=\"cell-default\">{row.data[column.dataName] || ''}</div>\n            {/if}\n          </div>\n        {/each}\n      </div>\n    {/each}\n  </div>\n</div>\n","<script>\n  import { afterUpdate, beforeUpdate, createEventDispatcher } from \"svelte\";\n  import debounce from \"debounce\";\n  const INPUT_DEBOUNCE_INTERVAL = 400;\n  const dispatch = createEventDispatcher();\n  export let textbox = null;\n  export let column;\n  export let rowNumber;\n  export let row;\n  let prevColumn;\n  let prevRow;\n  // [svelte-upgrade warning]\n  // beforeUpdate and afterUpdate handlers behave\n  // differently to their v2 counterparts\n  beforeUpdate(() => {\n    if (prevColumn !== column || prevRow !== row) {\n      const updateTextbox = () => {\n        if (textbox) textbox.value = row.data[column.dataName];\n      };\n      if (textbox) {\n        updateTextbox();\n      } else {\n        setTimeout(updateTextbox, 0);\n      }\n      prevColumn = column;\n    }\n  });\n  // [svelte-upgrade warning]\n  // beforeUpdate and afterUpdate handlers behave\n  // differently to their v2 counterparts\n  afterUpdate(() => {\n    /* Since data-grid isn't using a keyed each block to display the rows, we need to update\n      the focus as the grid scrolls. When this cell component receives a new row, check if the column's active row\n      is this row, and focus or blur if necessary */\n    if (prevRow !== row) {\n      if (column.activeRow && column.activeRow === rowNumber && textbox) {\n        textbox.focus();\n      } else if (textbox === document.activeElement) {\n        textbox.blur();\n      }\n      prevRow = row;\n    }\n  });\n  // [svelte-upgrade suggestion]\n  // review these functions and remove unnecessary 'export' keywords\n  export function onFocus(event) {\n    column.activeRow = rowNumber;\n  }\n  export function onBlur(event) {\n    // if blur event was user-initiated and not initiated by the blur call above,\n    // remove the activeRow property\n    if (event.sourceCapabilities) {\n      delete column.activeRow;\n    }\n  }\n  export function onInput(event) {\n    const value = textbox.value;\n    setTimeout(() => {\n      dispatch(\"valueupdate\", {\n        row,\n        column,\n        value,\n        rowNumber\n      });\n    }, 0);\n  }\n</script>\n\n<style>\n  .textbox-cell {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    background: white;\n    z-index: 3;\n  }\n  input {\n    height: 100%;\n    width: 100%;\n    border: 0;\n    margin: 0;\n    padding: 0 5px;\n    box-sizing: border-box;\n  }\n  input:active,\n  input:focus {\n    border: 1px solid lime;\n  }\n</style>\n\n<div class=\"textbox-cell\">\n  <input\n    type=\"text\"\n    on:input={onInput}\n    on:focus={onFocus}\n    on:blur={onBlur}\n    bind:this={textbox} />\n</div>\n","<script>\n  import { createEventDispatcher } from \"svelte\";\n  const dispatch = createEventDispatcher();\n  export let select = null;\n  export let column;\n  export let row;\n  export let rowNumber;\n  function getOptionDisplay(display) {\n    if (display instanceof Function) {\n      return display();\n    }\n    return display;\n  }\n  // [svelte-upgrade suggestion]\n  // review these functions and remove unnecessary 'export' keywords\n  export function onChange(event) {\n    // delay this until after the ui updates on the screen\n    setTimeout(() => {\n      dispatch(\"valueupdate\", {\n        row,\n        column,\n        value: select.value,\n        rowNumber\n      });\n    }, 0);\n  }\n</script>\n\n<style>\n  .select-cell {\n    background: white;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n  select {\n    border: none;\n  }\n  select {\n    width: 100%;\n    height: 100%;\n    padding: 0 5px;\n  }\n</style>\n\n<div class=\"select-cell\">\n  {#if column.options instanceof Array}\n    <select on:change={onChange} bind:this={select}>\n      {#each column.options as option}\n        <option\n          value={option.value}\n          selected={option.value === row.data[column.dataName]}>\n          {getOptionDisplay(option.display)}\n        </option>\n      {/each}\n    </select>\n  {/if}\n</div>\n","<script>\n  import { createEventDispatcher } from \"svelte\";\n  const dispatch = createEventDispatcher();\n  export let checkbox = null;\n  export let row;\n  export let column;\n  export let rowNumber;\n  // [svelte-upgrade suggestion]\n  // review these functions and remove unnecessary 'export' keywords\n  export function onChange(event) {\n    // delay this until after the ui updates on the screen\n    setTimeout(() => {\n      dispatch(\"valueupdate\", {\n        row,\n        column,\n        value: checkbox.checked,\n        rowNumber\n      });\n    }, 0);\n  }\n</script>\n\n<style>\n  .checkbox-cell {\n    text-align: center;\n    background: white;\n  }\n</style>\n\n<div class=\"checkbox-cell\">\n  <input\n    type=\"checkbox\"\n    bind:this={checkbox}\n    checked={row.data[column.dataName]}\n    on:click={onChange} />\n</div>\n","<script>\n  import DataGrid from \"svelte-data-grid-tmp\";\n  import TextboxCell from \"svelte-data-grid-tmp/src/textbox-cell.svelte\";\n  import SelectCell from \"svelte-data-grid-tmp/src/select-cell.svelte\";\n  import CheckboxCell from \"svelte-data-grid-tmp/src/checkbox-cell.svelte\";\n  import dRows from \"./dataset.json\";\n\n  let allowResizeFromTableCells = false;\n  let allowResizeFromTableHeaders = true;\n  let allowColumnReordering = true;\n  let rowHeight = 24;\n  let __affixedColumnIndices = [0];\n  let rows = dRows;\n  let columns = [\n    {\n      display: \"Row #\",\n      dataName: \"index\",\n      width: 60\n    },\n    {\n      display: \"Name\",\n      dataName: \"name\",\n      width: 250,\n      cellComponent: TextboxCell\n    },\n    {\n      display: \"Gender\",\n      dataName: \"gender\",\n      width: 100,\n      cellComponent: SelectCell,\n      options: [\n        {\n          display: \"Male\",\n          value: \"male\"\n        },\n        {\n          display: \"Female\",\n          value: \"female\"\n        }\n      ]\n    },\n    {\n      display: \"Active\",\n      dataName: \"isActive\",\n      width: 75,\n      cellComponent: CheckboxCell\n    },\n    {\n      display: \"Balance\",\n      dataName: \"balance\",\n      width: 115\n    },\n    {\n      display: \"Age\",\n      dataName: \"age\",\n      width: 45,\n      cellComponent: TextboxCell\n    },\n    {\n      display: \"Eye Color\",\n      dataName: \"eyeColor\",\n      width: 75,\n      cellComponent: SelectCell,\n      options: [\n        {\n          display: \"Green\",\n          value: \"green\"\n        },\n        {\n          display: \"Blue\",\n          value: \"blue\"\n        },\n        {\n          display: \"Brown\",\n          value: \"brown\"\n        }\n      ]\n    },\n    {\n      display: \"Email\",\n      dataName: \"email\",\n      width: 250,\n      cellComponent: TextboxCell\n    },\n    {\n      display: \"Company\",\n      dataName: \"company\",\n      width: 150,\n      cellComponent: TextboxCell\n    },\n    {\n      display: \"Address\",\n      dataName: \"address\",\n      width: 250,\n      cellComponent: TextboxCell\n    },\n    {\n      display: \"Favorite Fruit\",\n      dataName: \"favoriteFruit\",\n      width: 120\n    },\n    {\n      display: \"Registered\",\n      dataName: \"registered\",\n      width: 250\n    }\n  ];\n</script>\n\n<style>\n  h1 {\n    color: #ff3e00;\n    text-transform: uppercase;\n    font-size: 4em;\n    font-weight: 100;\n  }\n\n  :global(*) {\n    box-sizing: border-box;\n  }\n\n  .header {\n    text-align: center;\n  }\n\n  .controls {\n    width: 40%;\n    margin: 2em auto;\n  }\n  .grid-wrap {\n    width: 70%;\n    margin: 0 auto;\n    height: calc(100vh - 300px);\n    border: 1px solid black;\n  }\n</style>\n\n<div class=\"header\">\n  <h1>Data Grid Demo</h1>\n  <h4>40,000 rows</h4>\n</div>\n<div class=\"grid-wrap\">\n  <DataGrid\n    {rows}\n    {columns}\n    bind:allowResizeFromTableCells\n    bind:allowResizeFromTableHeaders\n    bind:allowColumnReordering\n    bind:rowHeight />\n</div>\n<div class=\"controls\">\n  <div>\n    <label>\n      <input type=\"checkbox\" bind:checked={allowResizeFromTableCells} />\n      Allow resize from table cells\n    </label>\n  </div>\n  <div>\n    <label>\n      <input type=\"checkbox\" bind:checked={allowResizeFromTableHeaders} />\n      Allow resize from table headers\n    </label>\n  </div>\n  <div>\n    <label>\n      <input type=\"checkbox\" bind:checked={allowColumnReordering} />\n      Allow dragging columns to new location\n    </label>\n  </div>\n  <div>\n    Row Height:\n    <input type=\"number\" bind:value={rowHeight} />\n  </div>\n</div>\n","import App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.body,\n\tprops: {\n\t\tname: 'world'\n\t}\n});\n\nexport default app;"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","i","length","d","element","name","document","createElement","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","value","removeAttribute","getAttribute","setAttribute","set_data","set_input_value","input","set_style","key","important","style","setProperty","current_component","set_current_component","component","get_current_component","Error","createEventDispatcher","type","detail","callbacks","$$","e","createEvent","initCustomEvent","custom_event","slice","call","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","push","add_flush_callback","flush","seen_callbacks","Set","shift","update","pop","callback","has","add","fragment","before_update","dirty","p","ctx","after_update","outroing","outros","group_outros","r","c","check_outros","transition_in","block","local","delete","transition_out","o","globals","window","global","outro_and_destroy_block","lookup","bind","index","props","undefined","bound","create_component","mount_component","on_mount","on_destroy","m","new_on_destroy","map","filter","destroy_component","make_dirty","then","fill","init","instance","create_fragment","not_equal","parent_component","prop_values","context","Map","ready","ret","hydrate","l","Array","from","childNodes","children","intro","SvelteComponent","[object Object]","this","$destroy","indexOf","splice","root","factory","deepDiff","validKinds","inherits","ctor","superCtor","super_","prototype","constructor","enumerable","writable","configurable","Diff","kind","path","defineProperty","DiffEdit","origin","DiffNew","DiffDeleted","DiffArray","item","arrayRemove","arr","to","rest","apply","realTypeOf","subject","Math","isArray","toString","test","hashThisString","string","hash","charCodeAt","getOrderIndependentHash","object","accum","hasOwnProperty","keyValueString","lhs","rhs","changes","prefilter","stack","orderIndependent","currentPath","normalize","alt","j","k","other","ltype","rtype","ldefined","getOwnPropertyDescriptor","rdefined","sort","akeys","keys","pkeys","isNaN","observableDiff","observer","accumulateDiff","difference","applyChange","source","change","it","last","applyArrayChange","u","defineProperties","diff","orderIndependentDiff","orderIndependentObservableDiff","orderIndepHash","applyDiff","revertChange","revertArrayChange","isConflict","$conflict","DeepDiff","module","DeepDiff.applyChange","DeepDiff.diff","EditHistory","obj","JSON","parse","stringify","forward","backward","newObj","patch","redo","undo","console","warn","x","display","headerComponent","getCellLeft","columnWidths","__affixedColumnIndices","__scrollLeft","floor","disallowResize","action_result","destroy","dataName","cellComponent","getComputedStyle","position","win","tabIndex","onload","contentDocument","defaultView","navigator","userAgent","cancel","old_blocks","get_key","dynamic","list","create_each_block","next","get_context","n","old_indexes","new_blocks","new_lookup","deltas","child_ctx","get","set","abs","will_move","did_move","first","new_block","old_block","new_key","old_key","left","getClosestIndex","closest","firstAffixedLeft","lastAffixedLeft","lastAffixedRight","closestLeft","dragCopy","enabled","copy","dragging","offsetX","onWindowMouseMove","pageX","onWindowMouseUp","which","body","onNodeMouseDown","innerHTML","width","height","textAlign","fontWeight","maxHeight","opacity","pointerEvents","overflow","background","createCopy","top","getBoundingClientRect","pageYOffset","documentElement","clientHeight","scrollTop","attachEvents","detachEvents","dispatch","wrapper","tableSpace","editHistory","rows","columns","rowHeight","allowResizeFromTableCells","allowResizeFromTableHeaders","allowColumnReordering","allowColumnAffix","__extraRows","__columnHeaderResizeCaptureWidth","__affixedRowIndices","__affixingRow","__affixingColumn","__rowActionLineTop","__rowAffixLineTop","__columnAffixLineLeft","__columnDragging","__columnIndexBeingDragged","__columnDragOffsetX","__resizing","__columnIndexBeingResized","__columnActionLineLeft","__innerOffsetHeight","__scrollTop","__scrolledAllTheWayToTheRight","eRows","onColumnAffixMouseMove","onColumnAffixEnd","wrapperPageX","offsetPoint","idx","indices","preventDefault","onRowAffixEnd","onColumnDragStart","columnIndex","onColumnDragMouseMove","onColumnDragEnd","newIdx","mColumns","setTimeout","onColumnResizeStart","stopPropagation","onColumnResizeMouseMove","resizeLineLeft","columnLeft","resizeLineMinLeft","newColumnWidth","max","onColumnResizeEnd","visibleRows","columnAffixLineLeft","numRows","gridSpaceWidth","gridSpaceHeight","numRowsInViewport","ceil","sum","start","end","ctrlKey","keyCode","rowNumber","column","scrollLeft","newScrollTop","newScrollLeft","scrollWidth","clientWidth","prevColumn","prevRow","textbox","row","updateTextbox","afterUpdate","activeRow","focus","activeElement","blur","sourceCapabilities","getOptionDisplay","Function","select","checkbox","checked","dRows","TextboxCell","SelectCell","CheckboxCell"],"mappings":"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"}