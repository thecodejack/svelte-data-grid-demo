{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\..\\App.svelte",
    "..\\..\\select-cell.svelte",
    "..\\..\\textbox-cell.svelte",
    "..\\..\\index.svelte",
    "..\\..\\checkbox-cell.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import DataGrid from \"svelte-data-grid-tmp\";\n  import TextboxCell from \"svelte-data-grid-tmp/src/textbox-cell.svelte\";\n  import SelectCell from \"svelte-data-grid-tmp/src/select-cell.svelte\";\n  import CheckboxCell from \"svelte-data-grid-tmp/src/checkbox-cell.svelte\";\n  import dRows from \"./dataset.json\";\n\n  let allowResizeFromTableCells = false;\n  let allowResizeFromTableHeaders = true;\n  let allowColumnReordering = true;\n  let rowHeight = 24;\n  let __affixedColumnIndices = [0];\n  let rows = dRows;\n  let columns = [\n    {\n      display: \"Row #\",\n      dataName: \"index\",\n      width: 60\n    },\n    {\n      display: \"Name\",\n      dataName: \"name\",\n      width: 250,\n      cellComponent: TextboxCell\n    },\n    {\n      display: \"Gender\",\n      dataName: \"gender\",\n      width: 100,\n      cellComponent: SelectCell,\n      options: [\n        {\n          display: \"Male\",\n          value: \"male\"\n        },\n        {\n          display: \"Female\",\n          value: \"female\"\n        }\n      ]\n    },\n    {\n      display: \"Active\",\n      dataName: \"isActive\",\n      width: 75,\n      cellComponent: CheckboxCell\n    },\n    {\n      display: \"Balance\",\n      dataName: \"balance\",\n      width: 115\n    },\n    {\n      display: \"Age\",\n      dataName: \"age\",\n      width: 45,\n      cellComponent: TextboxCell\n    },\n    {\n      display: \"Eye Color\",\n      dataName: \"eyeColor\",\n      width: 75,\n      cellComponent: SelectCell,\n      options: [\n        {\n          display: \"Green\",\n          value: \"green\"\n        },\n        {\n          display: \"Blue\",\n          value: \"blue\"\n        },\n        {\n          display: \"Brown\",\n          value: \"brown\"\n        }\n      ]\n    },\n    {\n      display: \"Email\",\n      dataName: \"email\",\n      width: 250,\n      cellComponent: TextboxCell\n    },\n    {\n      display: \"Company\",\n      dataName: \"company\",\n      width: 150,\n      cellComponent: TextboxCell\n    },\n    {\n      display: \"Address\",\n      dataName: \"address\",\n      width: 250,\n      cellComponent: TextboxCell\n    },\n    {\n      display: \"Favorite Fruit\",\n      dataName: \"favoriteFruit\",\n      width: 120\n    },\n    {\n      display: \"Registered\",\n      dataName: \"registered\",\n      width: 250\n    }\n  ];\n</script>\n\n<style>\n  h1 {\n    color: #ff3e00;\n    text-transform: uppercase;\n    font-size: 4em;\n    font-weight: 100;\n  }\n\n  :global(*) {\n    box-sizing: border-box;\n  }\n\n  .header {\n    text-align: center;\n  }\n\n  .controls {\n    width: 40%;\n    margin: 2em auto;\n  }\n  .grid-wrap {\n    width: 70%;\n    margin: 0 auto;\n    height: calc(100vh - 300px);\n    border: 1px solid black;\n  }\n</style>\n\n<div class=\"header\">\n  <h1>Data Grid Demo</h1>\n  <h4>40,000 rows</h4>\n</div>\n<div class=\"grid-wrap\">\n  <DataGrid\n    {rows}\n    {columns}\n    bind:allowResizeFromTableCells\n    bind:allowResizeFromTableHeaders\n    bind:allowColumnReordering\n    bind:rowHeight />\n</div>\n<div class=\"controls\">\n  <div>\n    <label>\n      <input type=\"checkbox\" bind:checked={allowResizeFromTableCells} />\n      Allow resize from table cells\n    </label>\n  </div>\n  <div>\n    <label>\n      <input type=\"checkbox\" bind:checked={allowResizeFromTableHeaders} />\n      Allow resize from table headers\n    </label>\n  </div>\n  <div>\n    <label>\n      <input type=\"checkbox\" bind:checked={allowColumnReordering} />\n      Allow dragging columns to new location\n    </label>\n  </div>\n  <div>\n    Row Height:\n    <input type=\"number\" bind:value={rowHeight} />\n  </div>\n</div>\n",
    "<script>\n  import { createEventDispatcher } from \"svelte\";\n  const dispatch = createEventDispatcher();\n  export let select = null;\n  export let column;\n  export let row;\n  export let rowNumber;\n  function getOptionDisplay(display) {\n    if (display instanceof Function) {\n      return display();\n    }\n    return display;\n  }\n  // [svelte-upgrade suggestion]\n  // review these functions and remove unnecessary 'export' keywords\n  export function onChange(event) {\n    // delay this until after the ui updates on the screen\n    setTimeout(() => {\n      dispatch(\"valueupdate\", {\n        row,\n        column,\n        value: select.value,\n        rowNumber\n      });\n    }, 0);\n  }\n</script>\n\n<style>\n  .select-cell {\n    background: white;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n  select {\n    border: none;\n  }\n  select {\n    width: 100%;\n    height: 100%;\n    padding: 0 5px;\n  }\n</style>\n\n<div class=\"select-cell\">\n  {#if column.options instanceof Array}\n    <select on:change={onChange} bind:this={select}>\n      {#each column.options as option}\n        <option\n          value={option.value}\n          selected={option.value === row.data[column.dataName]}>\n          {getOptionDisplay(option.display)}\n        </option>\n      {/each}\n    </select>\n  {/if}\n</div>\n",
    "<script>\n  import { afterUpdate, beforeUpdate, createEventDispatcher } from \"svelte\";\n  import debounce from \"debounce\";\n  const INPUT_DEBOUNCE_INTERVAL = 400;\n  const dispatch = createEventDispatcher();\n  export let textbox = null;\n  export let column;\n  export let rowNumber;\n  export let row;\n  let prevColumn;\n  let prevRow;\n  // [svelte-upgrade warning]\n  // beforeUpdate and afterUpdate handlers behave\n  // differently to their v2 counterparts\n  beforeUpdate(() => {\n    if (prevColumn !== column || prevRow !== row) {\n      const updateTextbox = () => {\n        if (textbox) textbox.value = row.data[column.dataName];\n      };\n      if (textbox) {\n        updateTextbox();\n      } else {\n        setTimeout(updateTextbox, 0);\n      }\n      prevColumn = column;\n    }\n  });\n  // [svelte-upgrade warning]\n  // beforeUpdate and afterUpdate handlers behave\n  // differently to their v2 counterparts\n  afterUpdate(() => {\n    /* Since data-grid isn't using a keyed each block to display the rows, we need to update\n      the focus as the grid scrolls. When this cell component receives a new row, check if the column's active row\n      is this row, and focus or blur if necessary */\n    if (prevRow !== row) {\n      if (column.activeRow && column.activeRow === rowNumber && textbox) {\n        textbox.focus();\n      } else if (textbox === document.activeElement) {\n        textbox.blur();\n      }\n      prevRow = row;\n    }\n  });\n  // [svelte-upgrade suggestion]\n  // review these functions and remove unnecessary 'export' keywords\n  export function onFocus(event) {\n    column.activeRow = rowNumber;\n  }\n  export function onBlur(event) {\n    // if blur event was user-initiated and not initiated by the blur call above,\n    // remove the activeRow property\n    if (event.sourceCapabilities) {\n      delete column.activeRow;\n    }\n  }\n  export function onInput(event) {\n    const value = textbox.value;\n    setTimeout(() => {\n      dispatch(\"valueupdate\", {\n        row,\n        column,\n        value,\n        rowNumber\n      });\n    }, 0);\n  }\n</script>\n\n<style>\n  .textbox-cell {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    background: white;\n    z-index: 3;\n  }\n  input {\n    height: 100%;\n    width: 100%;\n    border: 0;\n    margin: 0;\n    padding: 0 5px;\n    box-sizing: border-box;\n  }\n  input:active,\n  input:focus {\n    border: 1px solid lime;\n  }\n</style>\n\n<div class=\"textbox-cell\">\n  <input\n    type=\"text\"\n    on:input={onInput}\n    on:focus={onFocus}\n    on:blur={onBlur}\n    bind:this={textbox} />\n</div>\n",
    "<script>\n  import { onMount, afterUpdate } from \"svelte\";\n  import EditHistory from \"./edit-history\";\n  import * as deepDiff from \"deep-diff\";\n  import { createEventDispatcher } from \"svelte\";\n\n  const dispatch = createEventDispatcher();\n\n  const MIN_COLUMN_SIZE = 30;\n\n  let wrapper;\n  let tableSpace;\n\n  /**\n   * Computes the 'left' value for a grid-cell.\n   * @param {Number} i The cell index\n   * @param {Array} columnWidths The array of column widths in order\n   * @returns {Number}\n   */\n  function getCellLeft({\n    i,\n    columnWidths,\n    __affixedColumnIndices,\n    __scrollLeft\n  }) {\n    if (__affixedColumnIndices.indexOf(i) >= 0) {\n      if (i === 0) {\n        return __scrollLeft;\n      }\n      let left = __scrollLeft;\n      for (let j = i - 1; j >= 0; j--) {\n        left += columnWidths[j];\n      }\n      return left;\n    }\n\n    let left = 0;\n    for (let j = 0; j < i; j++) {\n      left += columnWidths[j];\n    }\n    return left;\n  }\n\n  /**\n   * Gets the closest column index given an x offset\n   * @param {Number} x The x offset\n   * @param {Array} columnWidths Array of column widths\n   * @param {Array} __affixedColumnIndices Array of column indices that have been affixed\n   * @param {Number} __scrollLeft The scrollLeft value of the scrollable container\n   * @returns {Number}\n   */\n\n  function getClosestIndex(\n    x,\n    columnWidths,\n    __affixedColumnIndices,\n    __scrollLeft\n  ) {\n    let closest = 0;\n\n    for (let i = 0; i < columnWidths.length; i++) {\n      const left =\n        getCellLeft({ i, columnWidths, __affixedColumnIndices, __scrollLeft }) +\n        Math.floor(columnWidths[i] / 2);\n\n      if (left < x) {\n        closest = i + 1;\n      }\n    }\n\n    // special handling required when there are affixed columns, because\n    // if the grid is scrolled horizontally to the right, we want to have this function return the closest\n    // affixed column, rather than any columns that might be closer to x but are being overlapped by an affixed column\n    if (__affixedColumnIndices.length > 0) {\n      const firstAffixedLeft = getCellLeft({\n        i: __affixedColumnIndices[0],\n        columnWidths,\n        __affixedColumnIndices,\n        __scrollLeft\n      });\n      const lastAffixedLeft = getCellLeft({\n        i: __affixedColumnIndices[__affixedColumnIndices.length - 1],\n        columnWidths,\n        __affixedColumnIndices,\n        __scrollLeft\n      });\n      const lastAffixedRight =\n        lastAffixedLeft +\n        columnWidths[__affixedColumnIndices[__affixedColumnIndices.length - 1]];\n      const closestLeft = getCellLeft({\n        i: closest,\n        columnWidths,\n        __affixedColumnIndices,\n        __scrollLeft\n      });\n      if (closestLeft > firstAffixedLeft && closestLeft < lastAffixedRight) {\n        if (closestLeft < lastAffixedRight && closestLeft > lastAffixedLeft) {\n          closest = __affixedColumnIndices[__affixedColumnIndices.length - 1];\n        } else {\n          for (let i = 0; i < __affixedColumnIndices.length; i++) {\n            const left =\n              getCellLeft({\n                i: __affixedColumnIndices[i],\n                columnWidths,\n                __affixedColumnIndices,\n                __scrollLeft\n              }) + Math.floor(columnWidths[__affixedColumnIndices[i]] / 2);\n\n            if (left < x) {\n              closest = __affixedColumnIndices[i] + 1;\n            }\n          }\n        }\n      }\n    }\n\n    return closest;\n  }\n\n  function getBodyScrollTop() {\n    return (\n      window.pageYOffset ||\n      (document.documentElement.clientHeight\n        ? document.documentElement.scrollTop\n        : document.body.scrollTop)\n    );\n  }\n\n  let editHistory = null;\n\n  export let rows = []; // Rows to display\n  export let columns = []; // Array of column definitions: { display: '', dataName: ''}, where display is what the display value is and dataName is what the key on the row object is\n  export let rowHeight = 24; // Row height in pixels\n  export let allowResizeFromTableCells = false; // Allow the user to click on table cell borders to resize columns\n  export let allowResizeFromTableHeaders = true; // Allow the user to clikc on table header borders to resize columns\n  export let allowColumnReordering = true; // Allow the user to drag column headers to reorder columns\n  export let allowColumnAffix = true; // Alow the user to affix columns to the left of the grid\n\n  export let __extraRows = 0; // Number of extra rows to render beyond what is visible in the scrollable area\n  export let __columnHeaderResizeCaptureWidth = 20; // The width of the area on column borders that can be clicked to resize the column\n  /**** Do not modify any of the data variables below ****/\n  export let __affixedRowIndices = []; // DO NOT MODIFY DIRECTLY. The row indices to affix to the top of the grid\n  export let __affixedColumnIndices = []; // DO NOT MODIFY DIRECTLY. The column indices to affix to the left side of the grid\n  export let __affixingRow = false; // DO NOT MODIFY DIRECTLY. Whether a row affix operation is in progress\n  export let __affixingColumn = false; // DO NOT MODIFY DIRECTLY. Whether a column affix operation is in progress\n  export let __rowActionLineTop = 0; // DO NOT MODIFY DIRECTLY. The 'top' position of the row action line\n  export let __rowAffixLineTop = 0; // DO NOT MODIFY DIRECTLY. The 'top' position of the row affix line\n  export let __columnAffixLineLeft = 0; // DO NOT MODIFY DIRECTLY. The 'left' position of the column affix line\n  export let __columnDragging = false; // DO NOT MODIFY DIRECTLY. Whether a column is being dragged\n  export let __columnIndexBeingDragged = null; // DO NOT MODIFY DIRECTLY. The column index that is being dragged\n  export let __columnDragOffsetX = 0; // DO NOT MODIFY DIRECTLY. The X offset of where the user clicked on the column header\n  export let __resizing = false; // DO NOT MODIFY DIRECTLY. Whether or not a column is currently being resized\n  export let __columnIndexBeingResized = null; // DO NOT MODIFY DIRECTLY. The column index being resized\n  export let __columnActionLineLeft = 0; // DO NOT MODIFY DIRECTLY. The 'left' position of the action line\n  export let __innerOffsetHeight = 0; // DO NOT MODIFY DIRECTLY. The height of the scrollable area on screen\n  export let __scrollTop = 0; // DO NOT MODIFY DIRECTLY. The scrollTop position of the scrollable area\n  export let __scrollLeft = 0; // DO NOT MODIFY DIRECTLY. The scrollLeft position of the scrollable area\n  export let __scrolledAllTheWayToTheRight = false; // DO NOT MODIFY DIRECTLY. Whether the container is scrolled all the way to the right as of the last onscroll event\n\n  onMount(() => {\n    editHistory = new EditHistory(rows);\n  });\n\n  /**\n   * TODO handle svelte 2's onupdate\n   **/\n  // onupdate(({ changed, current, previous }) => {\n  //   // Record the change in onupdate to allow the DOM to change before doing the deep diff\n  //   if (changed.rows && previous && previous.rows && previous.rows.length > 0) {\n  //     if (!current.skipRecord) {\n  //       this.editHistory.recordChange(current.rows);\n  //     } else {\n  //       this.set({ skipRecord: false });\n  //     }\n  //   }\n  // });\n\n  /**\n   * This action creates a half-opaque 'ghost' column header to visualize dragging a column into a different position\n   * This is put in an action because ultimately the ghost image has nothing to do with the actual column index move\n   */\n  function dragCopy(node, enabled) {\n    let copy = null;\n    let dragging = false;\n    let offsetX = 0;\n\n    function onWindowMouseMove(event) {\n      if (!dragging) {\n        return;\n      }\n      copy.style.left = event.pageX - offsetX + \"px\";\n    }\n\n    function onWindowMouseUp(event) {\n      if (!dragging || event.which !== 1) {\n        return;\n      }\n\n      dragging = false;\n      document.body.removeChild(copy);\n      copy = null;\n    }\n\n    function onNodeMouseDown(event) {\n      if (event.which !== 1) {\n        return;\n      }\n\n      dragging = true;\n      if (copy) {\n        document.body.removeChild(copy);\n      }\n\n      copy = createCopy();\n      offsetX = event.offsetX;\n      copy.style.top =\n        node.getBoundingClientRect().top + getBodyScrollTop() + \"px\";\n      copy.style.left = event.pageX - offsetX + \"px\";\n      document.body.appendChild(copy);\n    }\n\n    function createCopy() {\n      const copy = document.createElement(\"div\");\n      copy.innerHTML = node.innerHTML;\n      const { width, height, textAlign, fontWeight } = getComputedStyle(node);\n      copy.style.width = width;\n      copy.style.height = height;\n      copy.style.maxHeight = height;\n      copy.style.textAlign = textAlign;\n      copy.style.fontWeight = fontWeight;\n      copy.style.position = \"absolute\";\n      copy.style.opacity = \"0.5\";\n      copy.style.pointerEvents = \"none\";\n      copy.style.overflow = \"hidden\";\n      copy.style.background = \"#dddddd\";\n      copy.style[\"z-index\"] = \"99999\";\n\n      return copy;\n    }\n\n    function attachEvents() {\n      window.addEventListener(\"mousemove\", onWindowMouseMove);\n      window.addEventListener(\"mouseup\", onWindowMouseUp);\n      node.addEventListener(\"mousedown\", onNodeMouseDown);\n    }\n\n    function detachEvents() {\n      window.removeEventListener(\"mousemove\", onWindowMouseMove);\n      window.removeEventListener(\"mouseup\", onWindowMouseUp);\n      node.removeEventListener(\"mousedown\", onNodeMouseDown);\n    }\n    if (enabled) {\n      attachEvents();\n    }\n\n    return {\n      destroy() {\n        detachEvents();\n      },\n      update(enabled) {\n        if (enabled) {\n          attachEvents();\n        } else {\n          detachEvents();\n        }\n      }\n    };\n  }\n\n  function onWindowKeyDown(event) {\n    if (event.ctrlKey) {\n      if (event.keyCode === 90) {\n        undo();\n        event.preventDefault();\n      }\n\n      if (event.keyCode === 89) {\n        redo();\n        event.preventDefault();\n      }\n    }\n  }\n\n  /**\n   * Event handler for window's mousemove event\n   * @param {MouseEvent} event The MouseEvent object\n   */\n  function onMouseMove(event) {\n    onColumnDragMouseMove(event);\n    onColumnResizeMouseMove(event);\n    onRowAffixMouseMove(event);\n    onColumnAffixMouseMove(event);\n  }\n\n  /**\n   * Event handler for window's mouseup event\n   * @param {MouseEvent} event The MouseEvent object\n   */\n  function onMouseUp(event) {\n    onColumnDragEnd(event);\n    onColumnResizeEnd(event);\n    onRowAffixEnd(event);\n    onColumnAffixEnd(event);\n  }\n\n  /**\n   * Event handler for when a value has been updated\n   * @param {Object} event Event object with row and column objects\n   */\n  function onCellUpdated(event) {\n    rows[event.detail.rowNumber][event.detail.column.dataName] =\n      event.detail.value;\n    dispatch(\"valueUpdated\", event);\n  }\n\n  /**\n   * Applies the most recent backward change\n   */\n  function undo() {\n    const eRows = editHistory.undo();\n    if (eRows) {\n      rows = eRows;\n    }\n  }\n\n  /**\n   * Applies the most recent forward change\n   */\n\n  function redo() {\n    const eRows = editHistory.redo();\n    if (eRows) {\n      rows = eRows;\n    }\n  }\n\n  /**\n   * Event handler for starting column affix operation\n   */\n  function onColumnAffixStart(event) {\n    // left click only\n    if (event.which !== 1) {\n      return;\n    }\n    if (__affixedColumnIndices.length > 0) {\n      tableSpace.scrollLeft = 0;\n      __affixingColumn = true;\n    } else {\n      __affixingColumn = true;\n    }\n  }\n\n  /**\n   * Event handler for mousemove column affix operation\n   */\n  function onColumnAffixMouseMove(event) {\n    if (!__affixingColumn) {\n      return;\n    }\n\n    if (event.which !== 1) {\n      onColumnAffixEnd(event);\n      return;\n    }\n\n    const { left: wrapperPageX } = wrapper.getBoundingClientRect();\n\n    const offsetPoint = event.pageX - wrapperPageX + __scrollLeft;\n\n    const idx = getClosestIndex(\n      offsetPoint,\n      columnWidths,\n      __affixedColumnIndices,\n      __scrollLeft\n    );\n    const indices = [];\n    for (let i = 0; i < idx; i++) {\n      indices.push(i);\n    }\n\n    __columnActionLineLeft = offsetPoint;\n    __affixedColumnIndices = indices;\n    event.preventDefault();\n\n    // check to see if horizontal scroll position doesn't match where the\n  }\n\n  /**\n   * Event handler for ending column affix operation\n   */\n  function onColumnAffixEnd(event) {\n    __affixingColumn = false;\n  }\n\n  /**\n   * Event handler for starting row affix operation\n   */\n  function onRowAffixStart(event) {\n    __affixingRow = true;\n  }\n\n  /**\n   * Event handler for mousemove row affix operation\n   */\n  function onRowAffixMouseMove(event) {\n    if (!__affixingRow) {\n      return;\n    }\n  }\n\n  /**\n   * Event handler for ending row affix operation\n   */\n  function onRowAffixEnd(event) {\n    __affixingRow = false;\n  }\n\n  /**\n   * Event handler for column dragging\n   */\n  function onColumnDragStart(event, columnIndex) {\n    if (event.which !== 1) {\n      return;\n    }\n\n    // if the developer has disabled column reordering, don't begin a reorder\n    if (!allowColumnReordering) {\n      return;\n    }\n\n    __columnDragging = true;\n    __columnIndexBeingDragged = columnIndex;\n    __columnDragOffsetX = event.offsetX;\n    __columnActionLineLeft =\n      getCellLeft({\n        i: columnIndex,\n        columnWidths,\n        __scrollLeft,\n        __affixedColumnIndices\n      }) - __scrollLeft;\n  }\n\n  function onColumnDragMouseMove(event) {\n    if (!__columnDragging) {\n      return;\n    }\n\n    // if user is no longer pressing the left mouse button and we are out of sync\n    // with __columnDragging because mouseup didn't fire, finish the reorder\n    if (event.which !== 1) {\n      onColumnDragEnd(event);\n      return;\n    }\n\n    const { left: wrapperPageX } = wrapper.getBoundingClientRect();\n\n    // change the position of the action line to the closest column index under the mouse\n    const offsetPoint =\n      event.pageX - wrapperPageX + __scrollLeft - __columnDragOffsetX;\n    const idx = getClosestIndex(\n      offsetPoint,\n      columnWidths,\n      __affixedColumnIndices,\n      __scrollLeft\n    );\n    __columnActionLineLeft =\n      getCellLeft({\n        i: idx,\n        columnWidths,\n        __affixedColumnIndices,\n        __scrollLeft\n      }) - __scrollLeft;\n  }\n\n  /**\n   * Window mouseup handler for column dragging\n   */\n  function onColumnDragEnd(event) {\n    // user might try to be clever and middle-click to scroll horizontally while dragging a column\n    // don't stop the drag for middle clicks\n    if (event.which !== 1) {\n      return;\n    }\n\n    // if a column isn't being dragged, don't reorder anything\n    if (!__columnDragging) {\n      return;\n    }\n\n    const { left: wrapperPageX } = wrapper.getBoundingClientRect();\n    const offsetPoint =\n      event.pageX - wrapperPageX + __scrollLeft - __columnDragOffsetX;\n\n    // move column object to its new position in the array based off the mouse position and scroll position\n    const newIdx = getClosestIndex(\n      offsetPoint,\n      columnWidths,\n      __affixedColumnIndices,\n      __scrollLeft\n    );\n    let mColumns = columns;\n    mColumns.splice(\n      newIdx > __columnIndexBeingDragged ? newIdx - 1 : newIdx,\n      0,\n      mColumns.splice(__columnIndexBeingDragged, 1)[0]\n    );\n    columns = mColumns;\n    // delay firing of event so that new column order is accessible when handlers are called\n    setTimeout(() => dispatch(\"columnOrderUpdated\"), 0);\n\n    __columnDragging = false;\n    __columnDragOffsetX = 0;\n    __columnIndexBeingDragged = null;\n  }\n\n  /**\n   * Mousedown handler for column resizing\n   */\n  function onColumnResizeStart(event, columnIndex) {\n    // left click only\n    if (event.which !== 1) {\n      return;\n    }\n    const { left: wrapperPageX } = wrapper.getBoundingClientRect();\n\n    __resizing = true;\n    __columnActionLineLeft = event.pageX - wrapperPageX - __scrollLeft;\n    __columnIndexBeingResized = columnIndex;\n    event.stopPropagation();\n  }\n\n  /**\n   * Mousemove handler for column resizing\n   */\n  function onColumnResizeMouseMove(event) {\n    // if not currently resizing a column, ignore the event\n    if (!__resizing) {\n      return;\n    }\n\n    const { left: wrapperPageX } = wrapper.getBoundingClientRect();\n\n    const resizeLineLeft = event.pageX - wrapperPageX;\n    const columnLeft = getCellLeft({\n      i: __columnIndexBeingResized,\n      columnWidths,\n      __affixedColumnIndices,\n      __scrollLeft\n    });\n    const resizeLineMinLeft = columnLeft - __scrollLeft + MIN_COLUMN_SIZE;\n    const newColumnWidth = Math.max(\n      resizeLineLeft + __scrollLeft - columnLeft,\n      MIN_COLUMN_SIZE\n    );\n    // thanks to the virtual list, we're able to get away with setting the column's size while the mouse moves\n    columns[__columnIndexBeingResized].width = newColumnWidth;\n\n    __columnActionLineLeft = Math.max(resizeLineLeft, resizeLineMinLeft);\n\n    // If mouseup was not fired for some reason, abort the resize\n    if (event.which !== 1) {\n      __resizing = false;\n      __columnIndexBeingResized = null;\n\n      // delay firing the event until the next frame to guarantee that new values will be available in component.get()\n      setTimeout(\n        () =>\n          dispatch(\"columnWidthUpdated\", {\n            idx: __columnIndexBeingResized,\n            width: newColumnWidth\n          }),\n        0\n      );\n    }\n\n    // if still resizing and the user does not have the left mouse button depressed,\n    // the mouseup event didn't fire for some reason, so turn off the resize mode\n  }\n\n  /**\n   * Mouseup handler for column resizing\n   */\n  function onColumnResizeEnd(event) {\n    if (!__resizing) {\n      return;\n    }\n\n    dispatch(\"columnWidthUpdated\");\n    __resizing = false;\n    __columnIndexBeingResized = null;\n  }\n\n  /**\n   * Sets updated scroll values when the scrollable area is scrolled\n   */\n  function onScroll() {\n    // get new scroll values from the scroll area\n    const { scrollTop: newScrollTop, scrollLeft: newScrollLeft } = tableSpace;\n\n    /*\n     * To avoid doing unnecessary re-calculation of computed variables, don't set the scroll\n     * properties that haven't changed\n     */\n    if (__scrollTop !== newScrollTop) {\n      __scrollTop = newScrollTop;\n    }\n\n    if (__scrollLeft !== newScrollLeft) {\n      __scrollLeft = newScrollLeft;\n    }\n\n    __scrolledAllTheWayToTheRight =\n      Math.ceil(tableSpace.scrollWidth - tableSpace.scrollLeft) ===\n      tableSpace.clientWidth;\n  }\n\n  /**\n   * Computed Properties\n   */\n\n  /**\n   * The 'left' value of the column affix line\n   */\n\n  let columnAffixLineLeft = 0; //TODO setter probably not needed due to reactive statement\n\n  $: {\n    // if no columns are affixed, set the line all the way to the left\n    if (__affixedColumnIndices.length === 0) {\n      columnAffixLineLeft = 0;\n    }\n\n    let left = __scrollLeft;\n    for (let i = 0; i < __affixedColumnIndices.length; i++) {\n      left += columnWidths[__affixedColumnIndices[i]];\n    }\n\n    columnAffixLineLeft = left;\n  }\n\n  /**\n   * Array of column widths\n   */\n  let columnWidths = columns.map(x => x.width || MIN_COLUMN_SIZE); //TODO setter probably not needed due to reactive statement\n\n  $: {\n    // if width was not provided for this column, give it a default value\n    columnWidths = columns.map(x => x.width || MIN_COLUMN_SIZE);\n  }\n\n  /**\n   * The number of rows we have\n   */\n  let numRows = rows.length; //TODO setter probably not needed due to reactive statement\n\n  $: {\n    numRows = rows.length;\n  }\n\n  /**\n   * Width of the overall grid space\n   */\n  let gridSpaceWidth = 0; //TODO setter probably not needed due to reactive statement\n\n  $: {\n    let sum = 0;\n    for (let i = 0; i < columnWidths.length; i++) {\n      sum += columnWidths[i];\n    }\n\n    /**\n     * If the table is scrolled all the way to the right, resizing columns could\n     * accelerate until the column is the minimum width. Add some extra space on the right\n     * to ensure this undesired behavior does not happen. This doesn't seem like a perfect solution\n     * but it works for now until I can think of something better.\n     */\n\n    if (__resizing && __scrolledAllTheWayToTheRight) {\n      sum *= 2;\n    }\n\n    gridSpaceWidth = sum;\n  }\n\n  /**\n   * Height of the overall grid space\n   */\n  let gridSpaceHeight = rowHeight * numRows; //TODO setter probably not needed due to reactive statement\n  $: {\n    gridSpaceHeight = rowHeight * numRows;\n  }\n\n  /**\n   * Number of rows to render in the viewport\n   */\n  let numRowsInViewport = Math.ceil(__innerOffsetHeight / rowHeight);\n\n  $: {\n    numRowsInViewport = Math.ceil(__innerOffsetHeight / rowHeight);\n  }\n\n  /**\n   * Computes which rows should be visible\n   */\n  let visibleRows;\n\n  $: {\n    const start = Math.max(\n      0,\n      Math.floor(__scrollTop / rowHeight - __extraRows / 2)\n    );\n    const end = start + numRowsInViewport + __extraRows;\n\n    visibleRows = rows.slice(start, end).map((x, i) => {\n      return {\n        i: i + start, // for aria-rowindex\n        data: x // the row data\n      };\n    });\n  }\n\n  /**\n   * Helpers\n   */\n  const getCellZIndex = function(__affixedColumnIndices, i) {\n    return __affixedColumnIndices.indexOf(i) === -1 ? 1 : 2;\n  };\n\n  /**\n   * Gets the 'top' value for a grid-row\n   */\n  const getRowTop = function(i, rowHeight) {\n    return i * rowHeight;\n  };\n\n  // const getCellLeft =getCellLeft\n</script>\n\n<style>\n  .row-action-line {\n    position: absolute;\n    left: 0;\n    width: 100%;\n    height: 4px;\n    z-index: 6;\n    background: #aaa;\n  }\n\n  .row-affix-marker {\n    display: none;\n    position: absolute;\n    left: 0;\n    height: 4px;\n    z-index: 6;\n    background: white;\n    border-top: 1px solid #999;\n    border-bottom: 1px solid #999;\n\n    cursor: ns-resize;\n  }\n\n  .column-affix-marker {\n    position: absolute;\n    top: 0;\n    width: 4px;\n    z-index: 5;\n    background: white;\n    border-left: 1px solid #999;\n    border-right: 1px solid #999;\n    cursor: ew-resize;\n    transform: translateX(-50%);\n  }\n\n  .resizing * {\n    user-select: none;\n  }\n\n  .resizing .grid-inner {\n    overflow-y: hidden;\n  }\n\n  .resizing .grid-space {\n    pointer-events: all;\n  }\n\n  .grid-cell > * {\n    height: 100%;\n  }\n\n  .cell-default {\n    padding: 0 5px;\n    background: white;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n\n  .data-grid-wrapper {\n    position: relative;\n    width: 100%;\n    height: 100%;\n  }\n\n  .column-action-line {\n    position: absolute;\n    top: 0;\n    bottom: 17px;\n    z-index: 3;\n    width: 4px;\n    background: #aaa;\n    cursor: ew-resize;\n  }\n\n  .grid-cell-size-capture {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    z-index: 5;\n    background: transparent;\n    cursor: ew-resize;\n    pointer-events: all;\n  }\n\n  .grid-inner {\n    overflow: auto;\n  }\n\n  .grid-space {\n    position: absolute;\n    top: 0;\n    left: 0;\n    background: transparent;\n    pointer-events: none;\n\n    z-index: 3;\n  }\n\n  .grid-headers {\n    position: absolute;\n    overflow: hidden;\n    max-width: 100%;\n    width: 100%;\n    top: 0;\n    left: 0;\n    border-bottom: 2px solid black;\n  }\n\n  .grid-headers .grid-cell {\n    text-align: center;\n    font-weight: bold;\n    cursor: pointer;\n  }\n\n  .grid-headers .cell-default:hover {\n    background: #eee;\n  }\n\n  .grid-header-row {\n    position: absolute;\n    overflow: hidden;\n    top: 0;\n  }\n\n  .grid-row {\n    position: absolute;\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n  }\n\n  .grid-row:not(:last-child) {\n    border-bottom: 1px solid #666;\n  }\n\n  .grid-cell {\n    position: absolute;\n    top: 0;\n    text-overflow: ellipsis;\n    overflow: hidden;\n  }\n\n  .grid-cell > * {\n    width: 100%;\n  }\n\n  .grid-cell:not(:last-child) {\n    border-right: 1px solid #666;\n  }\n</style>\n\n<svelte:window\n  on:mouseup={onMouseUp}\n  on:mousemove={onMouseMove}\n  on:keydown={onWindowKeyDown} />\n<div\n  class=\"data-grid-wrapper {__resizing || __columnDragging ? 'resizing' : ''}\"\n  style=\"padding-top: {rowHeight}px;\"\n  bind:this={wrapper}\n  role=\"table\">\n  {#if __resizing || __columnDragging || __affixingColumn}\n    <div\n      class=\"column-action-line\"\n      style=\"left: {__columnActionLineLeft - 2}px;\" />\n  {/if}\n  {#if __affixingRow}\n    <div class=\"row-action-line\" style=\"top: {__rowActionLineTop - 2}px;\" />\n  {/if}\n\n  <div class=\"grid-headers\" style=\"height: {rowHeight}px;\" rolw=\"rowgroup\">\n    <!-- We link up the horizontal scrolling of the inner grid view with the sticky header row by making the\n      -- header row width 100% of the container, and using position:absolute along with 'left' to\n      -- control the 'scroll' of the header row -->\n    <div\n      class=\"grid-header-row\"\n      style=\"left: -{__scrollLeft}px; height: {rowHeight}px; width: {gridSpaceWidth}px;\"\n      role=\"row\">\n      {#each columns as column, i (i)}\n        <div\n          class=\"grid-cell\"\n          on:mousedown={event => onColumnDragStart(event, i)}\n          style=\"z-index: {getCellZIndex(__affixedColumnIndices, i)}; left: {getCellLeft(\n            { i, columnWidths, __affixedColumnIndices, __scrollLeft }\n          )}px; width: {columnWidths[i]}px; height: {rowHeight}px; line-height: {rowHeight}px;\"\n          title={column.display || ''}\n          use:dragCopy={allowColumnReordering}\n          role=\"columnheader\">\n          {#if column.headerComponent}\n            <svelte:component this={column.headerComponent} {column} />\n          {:else}\n            <div class=\"cell-default\">{column.display || ''}</div>\n          {/if}\n        </div>\n        {#if allowResizeFromTableHeaders && !column.disallowResize}\n          <div\n            class=\"grid-cell-size-capture\"\n            style=\"left: {getCellLeft({\n              i: i,\n              columnWidths,\n              __affixedColumnIndices,\n              __scrollLeft\n            }) + columnWidths[i] - Math.floor(__columnHeaderResizeCaptureWidth / 2)}px;\n            width: {__columnHeaderResizeCaptureWidth}px;\"\n            on:mousedown={event => onColumnResizeStart(event, i)} />\n        {/if}\n      {/each}\n    </div>\n  </div>\n\n  <div\n    class=\"grid-inner\"\n    bind:this={tableSpace}\n    bind:offsetHeight={__innerOffsetHeight}\n    on:scroll={onScroll}\n    style=\"height: 100%;\"\n    role=\"rowgroup\">\n\n    {#if allowColumnAffix}\n      <div\n        class=\"column-affix-marker\"\n        style=\"left: {columnAffixLineLeft}px; height: {gridSpaceHeight}px;\"\n        on:mousedown={onColumnAffixStart} />\n    {/if}\n    <div\n      class=\"row-affix-marker\"\n      style=\"top: {__rowAffixLineTop}px; width: {gridSpaceWidth}px;\"\n      on:mousedown={onRowAffixStart} />\n\n    <!-- We need an element to take up space so our scrollbars appear-->\n    <div\n      class=\"grid-space\"\n      style=\"width: {gridSpaceWidth}px; height: {gridSpaceHeight}px;\">\n      {#if allowResizeFromTableCells}\n        {#each columns as column, i}\n          {#if !column.disallowResize}\n            <div\n              class=\"grid-cell-size-capture\"\n              style=\"left: {getCellLeft({\n                i: i + 1,\n                columnWidths,\n                __affixedColumnIndices,\n                __scrollLeft\n              }) - Math.floor(__columnHeaderResizeCaptureWidth / 2)}px; width: {__columnHeaderResizeCaptureWidth}px;\"\n              on:mousedown={event => onColumnResizeStart(event, i)} />\n          {/if}\n        {/each}\n      {/if}\n    </div>\n\n    <!-- Loop through the visible rows and display the data-->\n    <!-- Scrolling seems to perform better when not using a keyed each block -->\n    {#each visibleRows as row, i}\n      <div\n        class=\"grid-row\"\n        style=\"top: {getRowTop(row.i, rowHeight)}px; height: {rowHeight}px;\n        width: {gridSpaceWidth}px;\"\n        role=\"row\"\n        aria-rowindex={row.i}>\n        {#each columns as column, j}\n          <div\n            class=\"grid-cell\"\n            style=\"z-index: {getCellZIndex(__affixedColumnIndices, j)}; left: {getCellLeft(\n              { i: j, columnWidths, __affixedColumnIndices, __scrollLeft }\n            )}px; height: {rowHeight}px; line-height: {rowHeight}px; width: {columnWidths[j]}px;\"\n            role=\"cell\">\n            {#if column.cellComponent}\n              <svelte:component\n                this={column.cellComponent}\n                rowNumber={row.i}\n                {column}\n                {row}\n                on:valueupdate={onCellUpdated} />\n            {:else}\n              <div class=\"cell-default\">{row.data[column.dataName] || ''}</div>\n            {/if}\n          </div>\n        {/each}\n      </div>\n    {/each}\n  </div>\n</div>\n",
    "<script>\n  import { createEventDispatcher } from \"svelte\";\n  const dispatch = createEventDispatcher();\n  export let checkbox = null;\n  export let row;\n  export let column;\n  export let rowNumber;\n  // [svelte-upgrade suggestion]\n  // review these functions and remove unnecessary 'export' keywords\n  export function onChange(event) {\n    // delay this until after the ui updates on the screen\n    setTimeout(() => {\n      dispatch(\"valueupdate\", {\n        row,\n        column,\n        value: checkbox.checked,\n        rowNumber\n      });\n    }, 0);\n  }\n</script>\n\n<style>\n  .checkbox-cell {\n    text-align: center;\n    background: white;\n  }\n</style>\n\n<div class=\"checkbox-cell\">\n  <input\n    type=\"checkbox\"\n    bind:this={checkbox}\n    checked={row.data[column.dataName]}\n    on:click={onChange} />\n</div>\n"
  ],
  "names": [],
  "mappings": "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"
}